{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"HMR 踩坑记","text":"昨天遇到一个问题：使用 next/tree 时报错，即使最简单的 Demo 也会报错，而官网提供的则不会，最终问题定位到 react-hot-loader 上。我使用的是 react-hot-loader@next版本，需要在 babel 配置中引入 react-hot-loader/babel plugin。禁用这个 plugin 正常渲染，启用就报错，这个问题太诡异了，所以有必要搞清楚 HMR。 了解 HMR热替换是 webpack 的很炫酷的特性，简直就是黑魔法般的存在。其实原理很简单，见下图（一直觉得别人画的图很厉害，虽然经常看不懂）： webpack-dev-server 服务启动之后与 webpack 建立连接，本地发生变化通知 webpack-dev-server，页面注入 devServerClient.js 脚本保持与 webpack-dev-server 通信。本地发生变化之后，通知浏览器，浏览器拉取最新的变化模块。 浏览器端维护着一个 modules: {} 集合，当某一个模块变更时，我们需要重新执行该模块，缓存模块对象。接下来就是如何重新渲染页面了，我们应该都见过下面这段代码。 123456if (module.hot) { module.hot.accept('./App', () =&gt; { // ... render(); });} 这段代码可以理解问监听模块变化，重新渲染页面。得益于消息冒泡，我们只需要监听最顶层的模块就可以了。重新渲染页面，对于 React 应用来说可以用这种方式： 12345678const render = () =&gt; { const nextApp = require('./App').default; // ...};setTimeout(() =&gt; { ReactDOM.unmountComponentAtNode(MOUNT_NODE); render();)); react-redux-starter-kit 就是这种方式。对于样式文件，sytle-loader 替我们做了热替换。我们在代码中引入样式文件：1import &apos;./Demo.css&apos; 实际上是这样的： 热替换更顺滑大多数的项目示例都是上面这种形式重新渲染页面，用户并不会体会到页面重刷的感觉。不过如果组件有自己的内部状态，这个状态肯定会丢失。为了将替换体验做的更顺滑，Dan Abramov 开发了 React Hot Loader 可以让更新组件时内部状态不丢失。react-proxy 会包装每个组件类，组件发生变化，只是实例原型上的方法改变，并不影响组件实例本身，只不过再次执行的是新的方法。 了解了这点之后，再检查下 next/tree 的代码就会发现，在 TreeNode 组件中包含有这样的代码逻辑：item.type === TreeNode 或者 children.type === TreeNode 来检查如果 children 是否是 TreeNode 类型。现在因为 react-proxy 包装了原来的组件类， children.type 类型其实是 ProxyComponent，虽然有着相同的属性和原型链，但其实是完全不同的对象，所以 children.type === TreeNode 结果就是 false。解决方法：我们在需要比较组件类型时，可以比较该类上的一个标识，或者比较原型链来绕过这个坑。 另外还有一点值得提下，HMR 的粒度是模块，因此如果在一个模块文件中创建几个类，其实里面的类型是不会被代理的。也就享受不到 react-hot-loader 带来的好处。 react-hot-loader 应用情况react-hot-loader beta 版本发布了很长时间，并未见到流行项目中用到，create-react-app，react-redux-starter-kit，dva， react-boilerplate。如果项目中用 redux 来管理 store，组件很少维护数据状态，确实这个特性并没那么大的吸引力。 相关文章： 探究Webpack中的HMR(hot module replacement) React Native 热加载（Hot Reload）原理简介 Webpack &amp; The Hot Module Replacement Webpack’s HMR &amp; React-Hot-Loader — The Missing Manual","link":"/2017/06/25/HMR-踩坑记/"},{"title":"初看 avalon","text":"因为需要考虑兼容低版本浏览器，想选择一个更为合适的MVVM框架，需要调研下 avalon，从一个 angular 使用者角度看 avalon（有排斥心理）。 MVVM首先是 MVVM，MVVM 方式的实现中，如何监测数据发生变化是一个问题。angular 实际并没有监听数据变化，在使用 angular 时改变 $scope 上数据，能够立即看到效果，原因是你修改数据的地方都是 angular 提供的，在 controller 内部、$http 回调以及 $timeout 回调，在你修改数据之后，angular 调用了一次$digest，所以数据能够发生变化，这也是为什么不建议你用 $.ajax 、settimetout 的原因。另外，众所周知 angular 脏检测效率低下，假设一个数据发生变化，需要调用相关的处理函数。在处理函数执行完成之后有可能再次引起数据变化，所以就需要再次检测….在这方面 avalon 用 hack 的方式，直接监测数据变化。 avalon 在 vm 上加入 getter setter watch数据变化。对于复杂 model 对象 vm.options.colsdef 最里层的变化就需要你自己监测了。 123// avalon 形如以下方式：vm.options.$watch('colsdef', function () {})// 当然 如果你对 options 添加新的属性，就.... 如果浏览器都支持 Object.observe 的话，MVVM也没这么折腾了。 ms-duplex 等同于 ng-model avalon 加入 data-duplex-observe=&quot;false&quot; 来禁止双向同步。 虽然在 ms-duplex 2.0 引入 ms-duplex-string、 ms-duplex-number、 ms-duplex-boolean、 ms-duplex-checked 取代原来的 ms-duplex-text、ms-duplex-bool、 ms-duplex-radio。感觉这些东西不是经过良好设计加入进来，而是为了解决现成的问题引入进来。angular 中的 ng-model提供的 $parsers（view 经该 pipeline 解析数据） $formatter（model 数据经该 pipeline 格式化显示）更给力。当然ms-duplex 在内部实现上也有一个 pipe 做数据适配过滤的。 指令avalon 在设计时考虑兼容性，抛弃了自定义标签。所有的标签都是由框架提供，也是下面的一些短板。不够优雅之处： ms-click-1，ms-click-2，ms-click-3 表示可以为某一个元素绑定 N 个点击事件。或许一般人也不会这么来做，完全可以在一个事件绑定中处理完这些事情。但是 ms-class-1 ms-class-2 可能是经常用到的。angular的写法 ng-class=&quot;{strike: deleted, bold: important, red: error}&quot;。 指令存在优先级 这个是神马 虽说对用户透明。但是还是引入了 ms-if-loop。 组件：没有了自定义标签，在组件化上就弱了很多。 1234&lt;!-- avalon写法：跟现在的组件写法差不多 --&gt;&lt;div ms-widget=\"accordion, accordionId, accordionOpts\"&gt;&lt;/div&gt;&lt;!-- angular写法 --&gt;&lt;accordion options=\"\"&gt;&lt;/accordion&gt; 另外，不知道全局配置在 avalon如何实现。比如对项目下所有的 pager 设置默认配置。 路由mm-router 虽说敢叫板 ng-router，但是跟 ui-router 比还是差很远。在权限验证和二级路由上，不知道怎么做的，还没深入使用。 12345678910// avalonavalon.router.get(\"/ddd/{dddID}/\", callback)// angular ui-router$stateProvider.state('adnav', { url: '', controller: 'AdnavCtrl', templateUrl: 'business/adnav.html', resolve: // 权限验证}) 小结avalon 宣称是一个迷你易用的 MVVM 框架，从文档上看，avalon 主要精力都在MVVM方面。除了 MVVM，angular 的依赖注入也是很不错的特性，尤其是。自定义标签可以在组件化上做很多事情。路由不及 ui-router 强大。组件化在当前的开发中，可以说是一种共识，React的流行就能看出。emberJs 也在做，虽说跟angular一样强依赖于框架。","link":"/2015/04/23/angularer-watch-avalon/"},{"title":"Angular启动","text":"本来有一篇很好的文章讲解启动流程，后来设为秘密的了，虽然有复制，但也不太好拿人家不愿共享的东西出来。在这就贴一下我的总结啦。 AngularJS加载完成后工作：1234567bindJQuery(); // 如果有JQuerypublishExternalAPI(angular); // 暴露对外APIjqLite(document).ready(function() { angularInit(document, bootstrap); //初始启动}); publishExternalAPI1234567891011121314151617publishExternalAPI: extendAngular() // 扩展bootstrap extend isArray... angularModule() // 定义angular.module module('ngLocale', []).provider('$locale', $localeProvider); //创建模块 // 实际结果是 _invokeQueue.push('$provider', 'provider', arguments); _invokeQueue是模块实例的一个属性，自己在控制台输出下一个模块所有的属性。 module('ng', ['ngLocale'], ['$provider', function ($provider){ $provider.provider({ $animate: $AnimateProvider, $browser: $BrowserProvider, $http: $HttpProvider, ...... }); }]); // 实际效果： _invokeQueue.push('$injector', 'invoke', arguments); // 为了批量添加，provider接收一个object module('app', []).controller('ctrl', function(){}); // 实际效果： _invokeQueue.push('$controllerProvider', 'registre', arguments); 假设我们自己定义了一个 app 模块。 123app.run(['$scope', '$http', function ($scope, $http) {}]);// 实际先添加在_runblocks上 angularInit 做的事情是，查找页面上的 ng-app，启动整个应用。doBootstrap 首先创建 injector，然后执行下面代码。 12345678injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', '$animate', function(scope, element, compile, injector, animate) { scope.$apply(function() { element.data('$injector', injector); compile(element)(scope); }); }]); 创建Injector的过程：1234567891011121314151617181920212223doBootstrap--&gt;createInjector(modules): //modules参数: ['ng', ['$provider', function () {$provide.value('$rootElement', element);}], 'App']; providerCache {$provider, $injector: providerInjector} providerInjector {get: 从providerCache中取} instanceCache instanceInjector loadModules: 递归加载Provider类，后加载的覆盖之前的。 loadModules(moduleFn.requires) invoke(_invokeQueue) { // 大致操作 ngLocale: $provider.provider('$locale', $localeProvider); } return _runBlocks.concat(reuqires._runBlocks); provider:每个应用注册的provider类全在providerCache中 providerCache['$httpProvider'] = $httpProvider; providerCache['$filterProvider'] = $filterProvider; ...... instanceInjector.invoke(['$rooScope', '$http', function ($rootScope, $http) {}]); instanceCache {$rootScope: ,$http: .....,Config} //获取$rootScope实例时，可能递归的创建了其他的实例。 每个应用只创建一个Injector，当然一个页面可以手动启动几个独立的app，好像还没人这么干。 从下面的代码中可以看到，一个app模块依赖的provider实例全在providerCache中，没错我说的就是xxProvider实例。 当我们定义一个provider时，我们知道它是包装过的一个函数 1function XXXProvider() {this._get = function () {}} 这个 providerCache 中保存的就是该函数的实例 instance 它有一个 _get 属性。而 instanceCache 中保存的是调用_get 返回的实例。 一个 Injector 的实现并不复杂，cache 存放 provider 和实例，invoke 方法将函数提供的 $inject 或者参数名称 name 映射为 cache[name]，然后调用函数。 将 Provider 类和 Provider 实例分开单独的 cache 和 injector是基于这样的考虑：Provider 类不应该注入一个实例，同样实例不应该注入一个 Provider 类。 内部实现一个 createInternalInjector 方法提取共同部分创建这两个 injector。如果在 instanceCache 中查找不到，providerInjector 又有对应的 Provider 类，则会从 providerInjector 获取到该 Provider 类实例化一个。 至于模块的 config 方法，当然是与 Provider 类有关，而 run 方法当然是与 Provider 实例有关。就是 12345//config(['xxProvider', function (xxProvider) {}]) 在Provider类注入完之后才应该调用，所以保存在_configBlocks 而非 _invokeQueue中providerInjector.invoke(['xxProvider', function (xxProvider) {}]);// run(function (){})instanceInjector.invoke(fn); 注册 directive 提供的的 directiveFactory 一般也不会被用到。注册的 Directive 有单独的 cache。$compile 的功能实现也不复杂，查找节点，以节点为参数调用对应 Directve 的 compile 方法。对每个节点都进行递归处理。","link":"/2014/10/31/angularjs-bootstrap/"},{"title":"AngularJS中的懒加载【翻译】","text":"原文 Lazy Loading In AngularJS 当我们使用 AngularJS 构建一个包含许多路由/视图的大型应用的时候，我们希望在最初加载的时，最好不加载所有的 artefacts，像 controller、directive 之类。理想情况下，最初加载时只加载必需的模块。之后用户改变路由，加载尚未加载的所需模块。这样做的好处不仅会加快页面初次加载速度，而且会节约带宽。这篇文章就介绍了在 AngularJS 架构的应用中如何懒加载 artefacts。 为了实现懒加载 controller 和 directives，首先需要弄清两个问题： 在应用启动之后，如何注册这些 artefacts 什么时候加载这些脚本 第一个问题是因为在应用启动后，不能使用模块 API 注册 artefacts。换句话说，如果我们尝试在已经启动的应用中使用下面的方式注册一个 controller: 123angular.module('app').controller('SomeLazyController', function($scope) { $scope.key = '...';}); 当你使用 ng-controller 指令引用到这个 controller 时，将会出现下面的错误提示： Error: Argument ‘SomeLazyController’ is not a function, got undefined 这时，在一个已经启动的应用中唯一注册 artefacts 的方式不是使用模块 API，而是使用 Angular provider。Providers 往往用来创建和配置 artefacts 的实例。因此为了注册一个 provider，你应该使用 $controllerProvider。同样，使用 $compileProvider 来注册 directive，使用 $filterProvider 注册 filter，使用 $provider 来注册服务。注册 controller 和 directive 的代码大概是这样的： 12345678910111213// Registering a controller after app bootstrap$controllerProvider.register('SomeLazyController', function($scope) { $scope.key = '...';});// Registering a directive after app bootstrap$compileProvider.directive('SomeLazyDirective', function() { return { restrict: 'A', templateUrl: 'templates/some-lazy-directive.html' }})// etc provider 只有在模块配置的时候可用，因此你需要保存一个引用，这样子就可以注册一个 artefact。类似于下面的方式： 123456789101112(function() { var app = angular.module('app', []); app.config(function($routeProvider, $controllerProvider, $compileProvider, $filterProvider, $provide) { app.controllerProvider = $controllerProvider; app.compileProvider = $compileProvider; app.routeProvider = $routeProvider; app.filterProvider = $filterProvider; app.provide = $provide; // Register routes with the $routeProvider });})(); 你就可以用这种方式注册controller：123angular.module('app').controllerProvider.resgister('SomeLazyController', function($scope) { $scope.key = '...';}); 还有另外一个问题，什么时候加载上面的脚本呢？在 route 的 resolve 属性中可以做到。 使用 $routeProvider 时，你可以指定一个可选的 key/factory 依赖表，这个会注入到 rotute controller 中，依赖表使用 resolve 指定如下： 12345$routeProvider.when('/about', { templateUrl:'views/about.html', controller:'AboutViewController', resolve:{ key: factory }}); 依赖表中的 key 作为依赖的 name，factory 要么是一个字符串，要么是一个函数。字符串作为服务的别名，函数使用返回值。如果函数返回的是 Promise，这个 Promise 在 route 开始渲染之前完成 resolved。这样我们就可以在依赖表中的函数中返回一个加载脚本的 Promise，保证在 route 开始渲染之前加载所依赖脚本。下面的例子中使用 $script 完成脚本加载： 123456789101112131415161718$routeProvider.when('/about', { templateUrl:'views/about.html', resolve:{ deps: function($q, $rootScope) { var deferred = $q.defer(); var dependencies = [ 'controllers/AboutViewController.js', 'directives/some-directive.js' ]; // Load the dependencies $script(dependencies, function() { // all dependencies have now been loaded by so resolve the promise $rootScope.$apply(function() { deferred.resolve(); }); }); return deferred.promise;}}}); 唯一需要注意的是promise的resolve很可能需要在AngularJS的环境中执行，像上面那样。可以使用$rootScope的$apply方法实现。如果不这样做的话，在页面完成加载时route不会开始渲染。 现在模块定义看起来像下面这样： 123456789101112131415161718192021222324252627282930313233(function() { var app = angular.module('app', []); app.config(function($routeProvider, $controllerProvider, $compileProvider, $filterProvider, $provide) { app.controllerProvider = $controllerProvider; app.compileProvider = $compileProvider; app.routeProvider = $routeProvider; app.filterProvider = $filterProvider; app.provide = $provide; // Register routes with the $routeProvider $routeProvider.when('/', { templateUrl:'views/home.html' }); $routeProvider.when('/about', { templateUrl:'views/about.html', resolve:{ deps: function($q, $rootScope) { var deferred = $q.defer(); var dependencies = [ 'controllers/AboutViewController.js', 'directives/some-directive.js' ]; $script(dependencies, function() { // all dependencies have now been loaded by $script.js so resolve the promise $rootScope.$apply(function() { deferred.resolve(); }); }); return deferred.promise; }}}); });})(); 最后，你可以用下面的方式启动应用：1234// This file will be loaded from index.html$script(['appModule.js'], function() { angular.bootstrap(document, ['app'])}); 以上就是实现懒加载的大概步骤。总之，首先在定义你的 app 模块时，保存相关 provider 实例的引用。然后你应该使用它们注册你自己的 artefacts，之后在定义 route 时，使用resolve返回一个 promise，在其中加载所需的脚本，完成之后 resolve promise，不要忘了在 $rootScope.$apply 里面。最后，加载完主模块后，你应该手动启动应用。 翻译之外可以看下 angular-lazyload，一样的思路! 也有反对的声音：不过并不提倡这种 hack 的方式，因为不符合 Angular 的设计思想。 Angular 将配置和执行独立分开，在配置块之外禁用 providers。这样做可能会导致 bug 和不可预期的结果，因为 AngularJS 在 injdector 创建之后并不期望再去注册 controller 和 directive。当然懒加载是一个很好的想法，不过我们应该等待框架支持而不是用 hack 的方式实现。在 AngularJS 2.0 中将支持这一特性。 之前在介绍启动的时候提过Angular启动： 在使用 module 的 api 时，并木有直接注册 controller，而是丢在了 _invokeQueue中。启动的时候，从队列中取出，完成加载：1$controllerProvidre.register('controllerName', function () {});","link":"/2014/11/01/angular-lazy-load/"},{"title":"Promise 被玩坏了","text":"收到产品同学反馈的一个 bug：在 iOS 上，进入首页之后很快滑动，再点击切换到第二个页面会一直处于loading状态，可以稳定复现。拿自己的手机试了几次果然可以复现。在模拟器上准备调试，打开控制台并未看到错误。于是猜想有异常没有处理，检查代码是否遗漏：1234showLoading();fetch(url).then(() =&gt; {}, () =&gt; ([])).then(() =&gt; { hideLoading();}); 对这段逻辑还是不放心，手动在 fetch 之后的 onsuccess，onerror 中打印调试信息，发现两个方法都没有调用。因为 Safari 不支持 fetch，开始怀疑引用的 fetch 有问题，加上调试信息： 123456789101112self.fetch = function (input, init) { return new Promise(function (resolve, reject) { var xhr = new XMLHttpRequest(); // ...省略部分代码 xhr.onload = function() { // ... console.log('---------&gt;', input); resolve(new Response(body, options)) }; // ...省略部分代码 });}; 一切正常 resolve 响应内容，但是就是不处理之后的 then 方法。手动在控制台敲：1new Promise(resovle =&gt; { resovle('haha'); }).then(data =&gt; { console.log(data); }, () =&gt; { console.log('wwwwwww'); }) 不打印任何结果。检查 Promise 确认是原生对象12Promise// function Promise() { [native code] } 之前看过的 Promise 实现是基于 setTimeout 实现，再测 setTimeout 是否正常123setTimeout(() =&gt; { console.log('it works');}, 10); 结果正常工作。既然是 Promise 有问题，就把原来的注释掉，换用 core-js 的实现，虽然 bug 照样复现，但好歹我们可以调试了。再次执行上面测试 Promise 的代码，发现 Promise 交给 mocrotask 执行时，压根未执行。关键代码：12345678910111213141516171819202122232425262728293031323334353637var Observer = window.MutationObserver || window.WebKitMutationObserver;module.exports = function(){ var head, last, notify; var flush = function(){ var parent, fn; console.log('&lt;---- flush'); while(head){ fn = head.fn; head = head.next; try { fn(); } catch(e){ if(head)notify(); else last = undefined; throw e; } } last = undefined; if(parent)parent.enter(); }; var toggle = true , node = document.createTextNode(''); new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new notify = function(){ console.log('notify----&gt;'); node.data = toggle = !toggle; }; return function(fn){ var task = {fn: fn, next: undefined}; if(last)last.next = task; if(!head){ head = task; notify(); } last = task; };}; 调试发现不知名的原因导致 head 不为空，追加任务只能追加在队列后面。手动调 flush 一下就会发现之前所有的未执行的任务都完成了处理。现在的问题就停留在是什么原因导致的 head 不为空。按说上面的代码确保队列里的任务最终都被处理， notify 之后都会触发 flush （注意不是说每个 notify 都会触发 flush，可能多个 notify 触发一次 flush ）。添加调试信息发现，某些情况下根本没有触发 flush，导致任务阻塞，Promise 被玩坏。 查看了其它 Promise （bluebird 以及 ES-promise）的实现，如果支持 MutationObserver 都会使用 MutationObserver，不支持才会降级到 setTimeout 。有人提示 Vue 的异步队列也用到了这个方案。 如何复现这种情况，调试时排除了路由的原因，只要在加载的时候滚动就会出现不触发 flush 的情况。尝试做了一个 demo 但是未能复现，google 了一下也未搜到 MutationObserver 相关 bug，只有一个类似 issues 。 当然禁用 MutationObserver 可以绕过这个问题。 如何验证这个问题，iOS 10.2 上（低版本 setTimeout 没有这个问题），对请求比较多的页面，未加载完成时就疯狂操作，争取能够稳定复现。","link":"/2017/01/19/Promise-被玩坏了/"},{"title":"工作中的前端工程化问题","text":"看过张云龙在git上关于前端集成的讨论，总结下工作中的问题。去年初的时候读过，之后也思考总结过我们平时开发项目中遇到的问题。现在再重新梳理一遍，主要是组件化。InfoQ 上的文章 &amp;&amp; github 上文章 先谈谈在工作中遇到的问题。平时工作中负责的管理系统较早的开始在两三年之前，采用了某个 SPA 框架，以及搭配的 UI。有几个现基于此技术系统需要不时升级维护。在开发过程中，经常遇到该 UI 引起的很诡异的 bug，并且该 UI 源码较难读懂维护。于是在新的系统中使用了另一套 UI，新的 UI 代码容易理解，也容易在此之上扩展。 遇到的问题最开始接触这些项目时，规规矩矩按照框架的配置规范开发页面，遇到问题看着代码排查，觉得还很顺手。时间久了，做的多了，感觉有不少重复的工作，比如每次添加页面做的事情有些过程是完全重复的。在一个项目中有一个复杂的页面，代码有 1000 多行。维护这个复杂的页面实在麻烦，于是开始思考解决这种问题。 在那个复杂的页面中，确实有很多事情要做，主要有几个大块头：一个按钮点击之后弹出对话框，选择几个数据，这样的组件有5个左右。然后显示在页面上；还有个是选择后的资源列表有优先级要求，要求支持排序；还有最下面的非常独特的功能强大的可编辑表格。 组件封装对这个问题，解决的方法是在原来的基础UI上，封装业务UI。将上面提到的大块头封装为一个业务级的UI组件，每个UI组件只对外暴露 setValue（编辑页面时，填充内容）， getValue（提交表单时，获取组件数据），render （渲染组件）。封装完业务UI之后，工作轻松了不少，不过还有些重复的劳动力，就是刚提到的每个页面很相似，只有少许的不同，每次新增模块，复制一份修改，也显得太不专业了。不过项目快结束了，不管了。 多个项目中的组件模块化重构完那个项目之后，接手了几个项目的维护工作。发现了更多的问题，总结一下大的问题： 几个项目的组织不尽相同，虽然项目大体是一致的，但在配置信息、用户信息、导航处风格不一样（插一句：导致如此的原因与选用的框架有关）。 有些项目还处于之前提到的状态，类似功能在几个项目中多种实现。 上面提到的新增一个模块，复制修改，在几个地方配置。 维护公共模块。几个项目中公用框架和基础UI，都是独立的。 采用的框架是独立的，遇到问题只能看代码，前人踩过的坑后人接着踩。 受上面文章影响，平时也用 grunt 工具，考虑用 yeoman 解决这些问题。对第一三问题，除了规范，就是使用 yo 定义 generation 生成项目脚手架，新增模块和组件都能用命令生成一个空的文件。对第四个问题最好的解决办法是，在一个独立的项目上维护这些公用库，搭建自己的私有 bower，维护自己的 cdn。对公用库，要求严格些，必须通过测试，有齐全的文档和 demo。第五个问题，可以在 gitlab 上记录 issue。 后来跟大家讨论过上面的问题之后，大家普遍觉得那个框架太旧了，不如投奔开源的，先看看 angularJS 吧。 文章之外业务UI 为什么有差异？项目时间长，前后负责项目的产品和码工都不是同一个人，更不用说几个不同的项目了。如果前端UI库齐全，可以反过来要求产品设计遵循规范的UI。","link":"/2015/01/07/fis-in-work/"},{"title":"es6 函数初始化绑定","text":"最近在看 es6 ，拿 quiz-es6 做测试。第一道题是关于函数初始化绑定的。 1234567(function(x, f = () =&gt; x) { var x; var y = x; x = 2; return [x, y, f()];})(1)// [2, 1, 1] 为了搞明白这段代码，看下规范中的描述。 为了解释这段代码的执行结果，我们从 函数对象 F 的 [[Call]] 内部方法说起。F.[[Call]] 接收两个参数 thisArgument 和 argumentsList，它的执行步骤如下（简单描述）： 准备环境 绑定this 执行 OrdinaryCallEvaluateBody(F, argumentsList) 恢复环境 上面步骤中的第三步又会执行 FunctionDeclarationInstantiation(F, argumentsList) 来进行函数声明初始化。这里的步骤很多（详见规范 9.2.12），简单描述下（忽略参数有重复情况）： 首先，将所有的函数（Function and Generator）声明 收集到 functionsToInitialize 。如果有多个同名函数，采用最后一个。 对所有形参，创建绑定 判断是否需要创建 arguments 对象。 三种情形除外：箭头函数，形参已含有 arguments，参数没有表达式并且 arguments 被占用（被 function | generator | let | const | class 声明占用） 根据是否严格模式，创建不同的 arguments 对象，并设置绑定初始化。 令 iteratorRecord 为以 arguments 为参数创建的迭代对象。 执行 IteratorBindingInitialization(iteratorRecord, env) 如果参数中没有表达式，对每个没有实例化的 VarDeclaredNames，创建绑定，并初始化为 undefined 否则，参数有表达式，以当前的环境为参数创建一个声明式环境 varEnv。对 VarDeclaredNames 中每个没有实例化的元素 n ： 如果 n 不在参数名列表中，或者 n 是一个函数名 设置初始值为 undefined 否则，初始值从原环境记录项 envRec 中获取。 注意（ 也就是说，如果 var 变量与形参同名，初始化时也有相同的值。） 如果不是 严格模式，再创建一个声明式环境，改变原来的词法环境 对所有的词法声明，在词法环境记录项上创建绑定。（注意，在此并未初始化） 对 functionsToInitialize 中的函数，实例化函数对象（以词法环境为参数）并在变量环境记录项上设置绑定值。 VarDeclaredNames ： FunctionDeclaration、 GeneratorDeclaration and VariableDeclarationLexicallyDeclaredNames ： let 、const and class IteratorBindingInitialization ：遍历处理所有形参，如果有初始值，并且形参未设置。对右侧求值，并设置形参的初始化值。 上面的第七步解释了 为何 y 的值为 1。以及 f() 的值为 1。 ES6 的规范比 ES5 多了不少内容。需要搞明白的时候再拿来慢慢阅读。","link":"/2016/02/28/es6-quiz/"},{"title":"前端错误日志","text":"记录工作学习中遇到的问题，有些错误比较常见，有些错误花费了较长时间折腾。 IE8以及以下split错误 信息：IE8以及下无法获取属性“split”的值: 对象为 null 或未定义 原因:[‘’,’’,’’,]在定义的数组中最后一个元素后多了个’,’ float:left左侧有空白 信息:在chrome下，container中元素article，float:left左侧有空白，该article无margin\\padding，父级元素container也无padding。 原因:在container的上面元素header,内容过高，又没有设置overflow:hidden 包含块级元素div的同一行元素不对齐 该行元素包括行级元素span ,同时包括了div设置了display:inline-block。 原因:设置align;vertical flash调用js的sb问题 信息:flash提供了一个接口，在视频播放的时候会调用JS的adplayerStatus方法。在测试过程中，如果单独的测试该方法是可以的。但是在系统中就是不调用该方法。 原因:后面的监控模块重写了该方法。所以–！不过在监控处理：如果该方法已经定义，保存如一个变量，并在监控中调用该方法。 还是flash的事 信息:在IE8下 flash无效果，一片空白。所以，开始的时候就一直查各个浏览器的flash嵌入代码是否有区别。 原因:后来发现每个flash上面都有个mask，JS用来响应点击事件的。该mask的opacity:0在IE8下设置的不同。之前负责的人在css中写的是filter:alpha(opacity:0)不明白为什么有这个，这样在IE中就不是透明的，如果设置mask的background:transparent鼠标会点击到flash上。调了半天发现问题原因之后，真想说自己是个大**！ widget中属性数据在定义的一个widget中，new出的实例感觉共用一个数据属性。 123456789$.widget('pandora.Checkbox', **, { options:{ w: 5, items: [{ label: '', value: 0 }] },}) 在每个实例出的操作的 w 是不同的，在操作 items 中元素时，多个 Checkbox 对象共用 items[0] 对象。随便查看 widget 方法，就会看到第三个形参名称是 prototype。这也就说明了为什么是多个对象操作的是同一个对象。 Jquery.ui.editable IE不能编辑 如下代码，在 chrome下 双击能够进入编辑状态，IE 下不能编辑。debug 时发现双击会触发提交事件。默认的情况下 submitBy:blur。 代码如下：123456$dom.editable({ editBy:\"dblclick\", type:\"textarea\", onSubmit:function(){ }}); 调试代码发现：进入编辑状态后的绑定事件。$this执行了blur的事件处理。注释该方法IE8下可以编辑。1234567$this.one(opts.submitBy, function () { opts.toNonEditable($(this), true);//注释该行IE8可以编辑。}).children().one(opts.submitBy, function () { opts.toNonEditable($(this).parent(), true);}); 问题：this 应该是一DIV 没有 blur事件，且也不应该触发。以后再看看了。 grunt plugin async创建 grunt 插件：http://javascriptplayground.com/blog/2014/01/creating-your-first-grunt-plugin/http://www.gruntjs.org/article/creating_tasks.html grunt 插件注册 task 中的异步事件不执行 (setTimeout process.nextTick() setImmediate)：必须123456var done = this.async();setTimeout(function () { // Todo stub****** done();}, 0);// node --debug-brk $(which grunt) task JS编码又是一个值得刻碑立柱的错误，查了一下午，才发现 js 文件编码是 utf-8；只在 IE6 下冒出非常奇怪的错误。调试的时候 alert 信息，插入的 alert 没有弹出窗口，但是后面的广告渲染出来了。一直以为是 IE6 的什么奇葩 bug，却未注意到文件编码问题。 IE人格分裂时隔大半年，向别人描述的时候竟然描述错了。源文章在(IE 全局变量的人格分裂症)[http://hax.iteye.com/blog/349569]bug原因：在两个不同的 js 中用两种方式声明全局变量。12345&lt;script type=\"text/javascript\"&gt; window['global'] = 'A';&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"out.js\"&gt;&lt;/script&gt;var global = 'B'; 之后你再获取 global 的值时，将会得到 undefined。大体是因为 JScript 引擎的设计与 IE DOM 对接的缺陷所导致。 IE6 insertBefore appendChild在往 Container 这个 Dom 中插入元素 ele 时，如果这个 Container 尚未完成加载。Container.appendChild(ele) 或 Container.insertBefore(ele) 都会导致出错。IE6下显示 无法打开站点，已经终止操作 页面崩溃。 最常见的 container 是 body。文档没有加载完成就在后面追加，导致崩溃。插入 body 前面可以避免这个问题：body.insertBefore(ele, body.firstChild);","link":"/2013/08/28/errorlog/"},{"title":"为开发者的设计","text":"design for developers 老外的 presentation 大概整理了下： 排版 字体大小最少14px 或者默认大小，有时也依赖字体； 可读长度不超过60字符；headings 1.1倍行高 段落1.5倍行高 对齐 接近原则（格式塔），留空白分组；数字6，font-size 12 line-height 18 font-size 16 line-height 24 主要元素间距6个单元 正常间距4个单元 较小间距 2个单元以6px作为一个单元 head与content间距4个单元-24px header上4个单元-24px，高16个单元-96px；适当使用空白，文字左对齐右侧空白合理使用。 光影 阴影不是纯黑 ；1-3px drop大小 0-3px距离；窗口阴影有点过度，但是表现了窗口居于所有内容之上。；按钮，渐变，从上到下由亮变暗，按下时内部阴影；千万不要只是交换阴影方向；一般来说，光源的方向来自120°角。 颜色 简单三色，head 类#000 body#333 减弱类#666；有背景色时，字体颜色千万不要是白色或灰色，简单设置rgb(255,255,255,0.9);颜色尽可能少，三色和红色警告、绿色成功提示，加上熟悉的配色。 图标 只用众所周知图标，否则使用文字，或文字加图标 重用设计 bootstrap 不要移去outline 总结：实际上，12px 的汉字实在是太小了，当然也跟分辨率设置有关。13px 的还差不多。verdana 字体看上还不错，不过放在在阅读的板块中间距显得大了点，所以下面就没用使用。简单看了下几个网站的间距、字体。13px 的中文还不少。行高在1.5左右。间距也是一样的，如果按照他所给的间距有时又显得太宽。按钮简单看了下几个网站的，bootstrap 的按钮点击状态并没用表现出太多区别，apple 的倒明显。musescore 的倒是变亮了。觉得 apple 的不错，下面用的就是 apple.com 的。另外，之前读的一篇文章讲层次感：背景色区域 — 实线 — 虚线 — 空白。这个在新闻网站页面分栏能够很好的体现出来。原文章不记得链接了。 最后依据这些原则简单定义了一些样式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657body { font-size: 12px; line-height: 1.5; color: #333;}h1, h2, h3, h4 , h5 { font-size: 16px; line-height: 1.1; color: #000;}header{ margin: 24px 0;}.container { width: 936px; margin: 0 auto;}aside { float: left; width: 216px;}.post{ margin-left: 240px;}input[type=\"text\"], input[type=\"email\"] , input[type=\"password\"], textarea{ border: 1px solid #ccc !important; border-radius: 4px; -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,0.075); box-shadow: inset 0 1px 1px rgba(0,0,0,0.075); -webkit-transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s; transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;}input[type=\"text\"]:focus, input[type=\"email\"]:focus, input[type=\"password\"]:focus, textarea:focus{ border-color: #66afe9 !important; outline: 0; -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(102,175,233,0.6); box-shadow: inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(102,175,233,0.6);}button, input[type=\"button\"], input[type=\"reset\"], input[type=\"submit\"]{ color: #FFF; border: 1px solid; border-radius: 4px; -webkit-box-shadow: inset 0 1px 1px 0 #6fc5f5; box-shadow: inset 0 1px 1px 0 #6fc5f5; background: #117ed2; background: -webkit-gradient(linear,left top,left bottom,from(#37aaea),to(#117ed2)); background-image: linear-gradient(to bottom,#37aaea 0,#117ed2 100%);}button:hover, button:focus, input[type=\"button\"]:hover, input[type=\"button\"]:focus,input[type=\"reset\"]:hover, input[type=\"reset\"]:focus, input[type=\"submit\"]:hover, input[type=\"submit\"]:focus{ background: #1c5bad; background: -webkit-gradient(linear,left top,left bottom,from(#2488d4),to(#1c5bad)); background-image: linear-gradient(to bottom,#2488d4 0,#1c5bad 100%); -webkit-box-shadow: inset 0 1px 1px 0 #64bef1; box-shadow: inset 0 1px 1px 0 #64bef1;}","link":"/2013/11/10/developer-design/"},{"title":"git 合并策略 之 recursive","text":"前几天老婆大人考察：git merge 时什么情况下进行 auto merge 以及如何 merge ? 我只能回答：如果文件同一行都有修改就会冲突，如果没有冲突就会自动 merge 。另一个问题是：如果一个文件删除了，为什么 merge 时还存在？这个应该是在另一个分支上对该文件做了修改。在阅读后面的文章之前，假定你理解 git 的分支是由 commit 串起来的一条链。如果不明白上一句话，请先补下 git 分支 知识点。 从 auto merge 说起，在我们合并两个分支时（不讨论 Fast-forward），如果两个分支没有冲突，经常会看到下面这句输出：Merge made by the 'recursive' strategy从 merge-strategies 文档中可以看到在 git 合并分支时可以指定合并策略，而 recursive 是默认的策略，该策略使用 3路合并算法。 three-way merge为方便解释，我们新建一个 git 仓库，在 master 分支新建一个 animals.txt，在 animals.txt 中添加这么几行内容：123catdogoctopus 第一个提交 commit 记为 B，然后切出一个分支 dev，在 dev 分支修改 octopus 为 tigger，commit 记为 E，在文件最后一行后插入一条 elephant，commit 记为 F；切回 master 分支，在文件第一行前插入一条 mouse，commit 记为 C, 修改 octopus 为 cow 记 commit 为 D。分支结构如下：123B-C-D master \\ E-F dev 其中 master 分支文件内容：1234mousecatdogcow dev 分支文件内容：1234catdogtiggerelephant 如果直接对两个文件进行 diff，我们是不知道如何进行 merge 的。因此我们就需要以原文件为参照进行三路合并。现在在 master 分支上执行 git merge dev ，需要进行三路合并的就是 B、D、F 这三个 commit。三路合并状态如下： 除了需要手动解决的冲突，三路合并很符合我们的期望。需要注意的是，三路合并只关心三个点，至于分支的历史它是不关心的。假设 dev 分支 commit F 中 tigger 改回 octopus，最后合并的结果是 cow。 recursive 又是什么？刚刚的三路合并提到了公共祖先，如果两个分支不止一个公共祖先怎么办？下面的希望你看明白了。 merge D 和 F时，发现 C 和 E 都是它们的公共祖先，而且这两个祖先还没有先后之分。如下：1234B--C---D master \\ \\ / \\ / \\ E---F dev 合并的策略是先合并 C 和 E 得到一个虚拟的公共祖先 G，再把这个虚拟节点作为公共祖先进行合并。那如果合并 C 和 E 的时候发现他们的公共祖先也不止一个怎么办？所以就要递归进行了。查询公共祖先的方法见 git-merge-base 好了，问题来了。如何实现 merge base?（提示：优先级队列） 至此，如果上面有叙述不清楚的地方，可以直接阅读下面的两个文章 three-way-merge merge-recursive-strategy","link":"/2017/02/22/git-合并策略-之-recursive/"},{"title":"前端模板","text":"原始的不足在最开始接触前端的时候，经常写这样的代码，当然不止做前端的时候都写过这样的代码。 123456var content = \"&lt;table&gt;&lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;score&lt;/th&gt;&lt;/tr&gt;\";for (var i = Things.length; i &gt;= 0; i--) { content += \"&lt;tr&gt;&lt;td&gt;\" + Things[i].name + \"&lt;/td&gt;&lt;td&gt;\" + Things[i].score + \"&lt;/td&gt;&lt;/tr&gt;\";}content += \"&lt;/table&gt;\";document.getElementById('table').innerHTML = content; smells bad! 太复杂且不利于阅读。使用引擎之后，可能是这样：(模板格式是自己随便写的，jekyll 使用的 liquid 模板，在这个项目中经常看到下面格式模板) 12345&lt;table&gt; &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;score&lt;/th&gt;&lt;/tr&gt; {{ \"{{ for student in Things\" }} }} &lt;tr&gt;&lt;td&gt;{{ \"{% student.name\" }} %}&lt;/td&gt;&lt;td&gt;{{ \"{% student.score\" }} %}&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; {`{与博客模板冲突，后面换成&lt;%之前算是学过 jsp 吧，对这样的标记并不陌生，&lt;%= %&gt; &lt;% %&gt;` 之间插入 java 代码，只不过 jsp 是编译成 servlet 的。 模板要达到的效果一个模板要达到的效果至少不能再让我用 + 连接字符串了。(之前的项目里就有一个 format 方法做这种事，用于将 html 模板中的 #{} 替换为变量值。之后模板最好支持分支逻辑和循环遍历，上面的 student.score 可能需要根据值以不同颜色显示。另外，经常是数据的展现形式与数据不完全相同，比如日期 date，输出的要求可能是(‘YYYY-MM-DD’)，还有经常出现的 bool 值，可能存的是 true false 或者 0 1 或者 yes no 显示的时候又要显示为中文 是 否等。如果支持一个适配函数的形式就比较方便。 标记选取 &lt;% %&gt;只是约定形式，个人喜好 &lt;%= %&gt;，&lt;% %&gt; 这种。上面文章也提到避免与后端标记冲突，模板标记转义。模板位置：现在比较常见的是放在 &lt;script&gt; 标签中。web components 组件规范中直接定义了一个 template 元素，不过并未广泛支持。 123&lt;script type=\"text/tmpl\" id=\"myTmpl\"&gt; 模板放这里......&lt;/script&gt; 关于性能：文章指出了性能是个伪命题，也给了理由。但还是需要了解下 artTemplate 性能高效原因：http://cdc.tencent.com/?p=5723(原文有链接) 预编译 各个模板简单说最终还是生成了一个 js 函数，预编译当然就是，，。 更快的字符串相加方式 很多人误以为数组 push 方法拼接字符串会比 += 快，要知道这仅仅是 IE6-8 的浏览器下。实测表明现代浏览器使用 += 会比数组 push 方法快，而在 v8 引擎中，使用 += 方式比数组拼接快 4.7 倍。 关于异常处理：就是模板函数执行错误时，artTemplate 能指定到行号。文中还给出了一个简单的 demo 方案。就是在生成的代码中每行插入 $liine = currentLine 这样的东西，感觉很老土，不知道 artTemplate 是不是采用的这种方式。 自己实现一个简单的模板解析jQuery 作者 john 开发的微型模板引擎 http://ejohn.org/blog/javascript-micro-templating/ 1234567891011121314151617181920212223242526272829303132333435// Simple JavaScript Templating// John Resig - http://ejohn.org/ - MIT Licensed(function(){ var cache = {}; this.tmpl = function tmpl(str, data){ // Figure out if we're getting a template, or if we need to // load the template - and be sure to cache the result. var fn = !/\\W/.test(str) ? cache[str] = cache[str] || tmpl(document.getElementById(str).innerHTML) : // Generate a reusable function that will serve as a template // generator (and which will be cached). new Function(\"obj\", \"var p=[],print=function(){p.push.apply(p,arguments);};\" + // Introduce the data as local variables using with(){} \"with(obj){p.push('\" + // Convert the template into pure JavaScript str .replace(/[\\r\\t\\n]/g, \" \") .split(\"&lt;%\").join(\"\\t\") .replace(/((^|%&gt;)[^\\t]*)'/g, \"$1\\r\") .replace(/\\t=(.*?)%&gt;/g, \"',$1,'\") .split(\"\\t\").join(\"');\") .split(\"%&gt;\").join(\"p.push('\") .split(\"\\r\").join(\"\\\\'\") + \"');}return p.join('');\"); // Provide some basic currying to the user return data ? fn( data ) : fn; };})(); 以下面的模板为例： 12345&lt;h3&gt; &lt;% if (typeof content === 'string') { %&gt; &lt;%= content %&gt; &lt;% } %&gt;&lt;/h3&gt; 解析之后生成的函数类似： 1234567891011function anonymous(obj/**/) { var p=[]; with(obj){ p.push(' &lt;h3&gt; '); if (typeof content === 'string') { p.push(' ', content ,' '); } p.push(' &lt;/h3&gt; '); } return p.join('');} 刚给出的模板引擎正则表达式那段不大容易看懂，作用就是将&lt;% %&gt;里面的内容直接作为字符串，其它的正文则是压入结果数组。我自己稍微改了下： 123456789101112131415var cache = {};this.tmpl = function (str, data) { var fn = !/\\W/.test(str) ? cache[str] = cache[str] || tmpl(document.getElementById(str).innerHTML) : new Function(\"obj\" , \"var p = []; with(obj){\" + format(str) + \"};return p.join('');\"); return data ? fn(data) : fn;};function format (str) { str = '%&gt;' + str + '&lt;%'; return str.replace(/[\\r\\n\\t]/g, ' ') .replace(/&lt;%=(.*?)%&gt;/g, \"',$1,'\") .split(\"&lt;%\").join(\"');\") .split(\"%&gt;\").join(\"p.push('\");} 测试页面在：http://fiddle.jshell.net/fedeoo/6jwMy/2/show/ 一篇讲设计模板引擎的文章，不过本身没有讲如何设计。http://www.toobug.net/article/how_to_design_front_end_template_engine.html","link":"/2013/10/15/front-template/"},{"title":"introduce to websocket","text":"背景在 webSocket 出现之前，为了实现消息推送，实现方式有轮询和Comet。Comet 又分两种：长轮询和流技术。 webSocket APIwebSocket 使用非常简单，API 比较简单：123456const ws = new WebSocket('ws://localhost:8080');ws.onopen = function() {};ws.onmessage = function() {};ws.onclose = function() {};ws.send('');ws.close() 握手webSocket 需要借助 HTTP 协议，如果是 https 协议，则使用 wss 协议 123456GET ws://dw-dev.alibaba-inc.com:8080/sockjs-node/056/yqjbei0m/websocket HTTP/1.1Connection: UpgradeUpgrade: websocketSec-WebSocket-Version: 13Sec-WebSocket-Key:PnmANvXSAsaE+HljkwpFLA==Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits 123Connection: UpgradeUpgrade: websocketSec-WebSocket-Accept:y2AYVF5ss1DbiA0wKhARD3d37fw= 服务端代码 Node.js 实现：123456789const server = http.createServer();server.on('upgrade', (req, socket) =&gt; { const secKey = req.headers['sec-websocket-key']; socket.write('HTTP/1.1 101 Web Socket Protocol Handshake\\r\\n' + 'Upgrade: WebSocket\\r\\n' + `Sec-WebSocket-Accept: ${calcAcceptHash(secKey)}\\r\\n` + 'Connection: Upgrade\\r\\n' + '\\r\\n');}); 服务端必须返回 Sec-WebSocket-Accept，否则浏览器将抛出错误。 Sec-WebSocket-Accept 的计算方法是 原 key 与 ‘258EAFA5-E914-47DA-95CA-C5AB0DC85B11’ （魔数）字符串拼接再取 sha-1 哈希值的 base64 编码。代码描述：12const MAGIC_STRING = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';crypto.createHash('sha1').update(secKey + MAGIC_STRING).digest('base64'); 另外，服务端可以拒绝同一客户端的多个连接以避免 DOS 攻击。 数据帧1234567891011121314151617 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len | Extended payload length ||I|S|S|S| (4) |A| (7) | (16/64) ||N|V|V|V| |S| | (if payload len==126/127) || |1|2|3| |K| | |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +| Extended payload length continued, if payload len == 127 |+ - - - - - - - - - - - - - - - +-------------------------------+| |Masking-key, if MASK set to 1 |+-------------------------------+-------------------------------+| Masking-key (continued) | Payload Data |+-------------------------------- - - - - - - - - - - - - - - - +: Payload Data continued ... :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +| Payload Data continued ... |+---------------------------------------------------------------+ 数据长度可变；第二字节标示的 len 为 126 时，后面 16 位作为 payload 长度。如果为 127，用后面 64 位。 Mask 如果是客户端发送则必需。浏览器随机生成掩码，避免随意伪造发送内容。 1234var DECODED = \"\";for (var i = 0; i &lt; ENCODED.length; i++) { DECODED[i] = ENCODED[i] ^ MASK[i % 4];} opcode 4位0x0 denotes a continuation frame0x1 denotes a text frame0x2 denotes a binary frame0x8 关闭0x9 (Ping)0xA (Pong)其它保留 应用webpack-dev-server 断开重连-指数退避算法webpack-hot-middleware SSE ReadMoreaboutwebsocketWriting_WebSocket_servers服务端实现全部代码可以参考 留香的 easy-websocket","link":"/2017/08/31/introduce-to-websocket/"},{"title":"也谈 JS 模块","text":"跟大多数人一样，在最初接触JS时，没有考虑过模块的概念。当工作中前端做的事情越来越复杂，JS 越来越庞大，就必须好好考虑组织 JS 代码了。了解其它语言的人，可能会惊讶 JS 没有模块。当每个人都在做这件事情的时候，就不得不归咎到语言问题上了，或许在以后的规范中将加入对模块的支持。不过现在的我们还是有必要了解下怎么组织模块和懒加载的思想。 闭包和命名空间解决方案当项目越来越复杂时，在项目开发中必须保证变量不冲突，当然最该考虑的就是约定，大家遵守同一个命名规范。不过总会用到别人的代码，外部代码就不一定遵从同一个规范了，为了避免变量冲突，最简单的处理，我们可以把代码包在一个匿名函数中。就像这样：1234567(function () { //变量 函数 var privateMember; function privateMethod () { //.... }})(); 如果我们的其它模块需要访问该文件中的变量或函数，我们可以这样：123456789var m1 = (function ($) { var privateMember; function privateMethod () { } return { publicMethod: privateMethod };})(Jquery); 或者直接交给全局：12345678910(function (global, $) { //变量 函数 var privateMember; function privateMethod () { //.... } global.m1 = { };})(global, Jquery); 将全局变量导入模块，作为局部变量解析速度更快。 使用模块模式，建立命名空间，假设项目名称：pandora；用户相关名称 pandora.user，可以这样约定命名规则。12345678910111213141516171819202122232425262728293031//代码出处：Javascript 模式var pandora = pandora || {};pandora.namespace = function (ns_string) { var parts = ns_string.split('.'), parent = pandora, i; if (parts[0] === \"pandora\") { parts = parts.slice(1); } for (i = 0; i &lt; parts.length; i += 1) { if (typeof parent[parts[i]] === 'undefined') { parent[parts[i]] = {}; } parent = parent[parts[i]]; } return parent;}//使用var moudle = pandora.namespace('utilities.array');pandora.utilities.array = (function () { var privateVariable = {}; function privateMethod () { //... } return { publicMethod: privateMethod };})(); 模块化编程上面提到的是命名冲突，还有文件依赖问题。我们引入 Node.js 支持的模块编程，将上面代码改为模块的方式：12345678910111213141516//代码片段 003 math.jsdefine(function (require, exports) { //变量 函数 var privateMember; function privateMethod () { //.... } exports.publicMethod = privateMethod;});//在另一个模块中 net.jsdefine(function (require, exports) { var math = requeire('math'); math.publicMethod();}); Node.js 的模块系统就是这种方式，只不过不需要用户自己写define, node会对文件进行处理，Node.js 是服务端的应用当然可以这么写，而且读取文件依赖也是同步的。 同步模块实现如果我们要在浏览器端实现上面提到的模块功能，应该解决哪些问题呢？ define 应该实现功能： 定义一个模块，模块 id 按照脚本 url 获取， 同时包括一个 function require 应该实现功能：获取模块，返回的是模块中的 exports。 为避免重复，我们在全局变量 cacheMods 中保存加载的模块，并且保存 exports。每个模块应该是这么一个对象：12345{ id: uri, factory: function(require, exports){}, exports: *** || {}} 根据上面的分析： define和require的功能伪代码大概是这样的1234567891011function define (f) { var uri = getCurrentScriptUri(); //该uri是当前脚本路径 var mod = new Module(uri, f); mod.exports = factory(require, mod.exports, mod); cacheMods[uri] = mod;}function require (uri) { var mod = cacheMods[uri]; return mod.exports;} 还有一个问题，当调用require的时候该模块还没加载怎么办？ 先考虑如果是同步加载的话：我们可以这样子，加载该模块代码–简单的说就是插入一个script （src=’uri’）当这个脚本加载完成后，执行define就有了这个模块。 上面的require代码也需要调整一下：123456789101112function require (uri) { var mod = Module.get(uri); return mod.exports;}Module.get: function (uri) { var mod = cacheMods[uri]; if (!mod) { var mod = new Moudule(uri); mod.load(); } return mod;} 好简单啊！不过load方法必须是同步的，必须检测到依赖的模块已加载完成后才能往下执行。 异步加载模块实现如果我们要采用异步加载的方式，就不能在require时 加载依赖脚本。 在代码片段003我们也能看出，在define的时候，require是不会执行的。我们可以在define的时候指明模块依赖，在define的时候就把所依赖模块下载下来。模块也多了一个属性deps，表明所依赖的模块; 问题是这样强制用户指明依赖，是不是不太好。那我们自己来，分析下factory.toString()中的require (‘’);语句 获取到deps。 这下就简单多了，不过还没完，所依赖的所有模块加载完成后，应该告知模块。并标示该模块的状态。003中的math模块加载完成后应该通知net模块。现在我们的模块应该定义成这样：123456789{ id: uri, factory: function(require, exports){}, exports: *** || {}, deps: [], status: 0, //标识模块状态 _awaiting: [], //等待该模块的模块队列 _remain: deps.length //当前模块依赖的deps还有几个没加载} 1234567891011121314151617181920212223//模块定义也变得复杂了点function define (deps, factory) { var mod = cacheMods[uri] = new Module(uri, f, deps); mod._remain = deps.length; mod._awaiting = {}; for (var i = deps.length - 1; i &gt; 0; i--) { Module.get(deps[i]).load(); } //如果依赖的模块都已加载完成调用onload if (loadedAlldeps) { mod.onload(); }}function load () { var this; this.fetch();//在页面插入script 脚本加载之后又会调用define}function onload () { //检查 _awaiting 上阻塞的模块 并对激活的模块 调用相应的 onload 方法} 现在我们的模块应该差不多了。上面的 require 方法获取 mod 的 exports，如果多个地方调用 require(‘math’),也应该只有一个 exports，也就是每个模块的 factory 只执行那么一次。我们再稍微改下：1234567function require (uri) { var mod = Module.get(uri); return mod.exec();}function exec () { return exports || mod.factory(require, mod.exports, mod);} 启动执行第一个模块，我们的入口代码 只需要 require('main') 就可以了。等等，貌似哪里不对。main 模块这个时候还没加载啊。我们可以定义一个依赖 main 模块的 mod，加载这个12345var mod = new Module(['main']);mod.onload = function() { mod.exec();}mod.load(); 以上描述了 CMD 模块加载器 seajs 的大概实现。seajs 就不用介绍。在 seajs 中 define 是个全局的函数，而 require 是一局部的变量。在 define 的时候并不做加载操作。我们看下 seajs 整个的结构12345678910111213141516171819202122232425262728function Module(uri, deps) { //没有 factory}Module.prototype.load = function () { //加载依赖模块 //没用下载的模块 调用fetch}Module.prototype.onload = function () { //模块加载完成后的回调，通知_awaiting上的模块，如果所有依赖也完成就调用它的onload}Module.prototype.fetch = function () { //下载脚本，脚本下载完成后回调 load}Module.prototype.exec = funcction () { //执行factory 得到exports function require(id) { return Module.get(require.resolve(id)).exec() }}Module.define = function (id, deps, factory) { parseDependencies();}Module.get = function (uri, deps) {}Module.use = function (ids, callback, uri) { //加载匿名模块} 当然还是有不少差别的，上面我们实现的是简化了很多的。seajs引入模块：1seajs.use(\"examples/hello/1.0.0/main\"); 如果懒得提供匿名模块加载方式，我们也能用类似的方式来启动第一个模块：12345var mod = seajs.cache['main'] = new seajs.Module('main' , ['examples/hello/1.0.0/main']);mod.callback = function() { seajs.cache[seajs.resolve('examples/hello/1.0.0/main')].exec();};mod.load(); 模块周边大概或许就是这样，再来谈下文件合并的问题。CMD规范中一个文件只有一个模块，我们不能直接将所有模块连接到一个文件中。在seajs中定义的匿名模块是根据脚本的uri生成id的。在合并的时候必须指定该uri为id。即将原来的模块定义改成。123//代码片段 003 math.jsdefine('main.js', [], function (require, exports) {}); seajs文件的合并是用spm-js做的。 最后，提下 smash，d3 用到的一个文件拆分的处理方式。在 JS 中可以这么用 1import \"math\" 在运行前重新生成合并文件。主要是用 namespace 避免污染变量，这样的好处就是实际生成的 JS 还是原来的 JS 代码，但是在开发的时候各个文件很小，在开发的时候感觉更为清晰些（我们的一个项目中有用过这东东）。","link":"/2014/02/13/about-js-module/"},{"title":"阅读文章记录","text":"读别人的博文的时候，觉得好的，有时会收藏。觉得不对的地方也记录一下。 jquery-原理-机制文章出处：http://www.zhangxinxu.com/wordpress/2013/07/jquery-%E5%8E%9F%E7%90%86-%E6%9C%BA%E5%88%B6/1234567var F = function(id) { this.element = document.getElementById(id);};F.prototype.hide = function() { this.element.style.display = \"none\";};new F(\"image\").hide(); 作者说这种方式将 element 暴露给了 var f = new F() 对象。很明显我们可以这样访问 f.elemen 或者 f.hasOwnProperty('element')。作者在第五步给出了隐藏的方案：1234567891011var F = function(id) { return this.getElementById(id);};F.prototype.getElementById = function(id) { this.element = document.getElementById(id); return this;};F.prototype.hide = function() { this.element.style.display = \"none\";};new F(\"image\").hide(); 同样有人质疑：f 对象一样有 element 属性。作者的解释是：第 5 条的 element 不是在包装器对象本身上，而是在原型上。而我认为是没区别的，打印 f，也能看到 f 是有 element 属性的。在原型上是什么意思？f.__proto__ 上？那 var f1 = new F('f1'); 与 var f2 = new F('f2'); f1与 f2 岂不是共用 element ？所以也不是第九给出的原型结构那样。其实结果是一样的，这样写的真正目的是不用 new 也要返回一个对象。就如下面的结果：不管是用 new $(‘’).each() 还是$(‘’).each()都可以。最后的代码：123456789var $ = function(selector, context){ return this.init(selector, context);};$.fn = $.prototype;$.fn.init = function(selector, context){ return this;};$.fn.each = function(){} reflow rerender浏览器原理浏览器内部工作原理：http://www.kb.cnblogs.com/page/129756/在比较多的文章中(http://my.oschina.net/u/1162598/blog/158823)指出：合并样式操作减少回流。但是记得在之前的 js 线程分析中说：js 是单线程的，所以在当前的js执行完后才会执行渲染线程。那合并不合并的是不是也就无所谓了。或者说每次的样式操作都会加入到一个渲染队列，在执行渲染线程的时候依次从队列执行。如果是这样，合并样式确实有用。当然也有文章说是每次样式操作加入到一个队列中，那这样子，浏览器渲染的时候肯定是进行优化的。一篇文章中提了读写的顺序，将操作顺序改变：rwrw ==&gt; rrww。渲染线程是个单独的线程。 关于jshint有话说loopfunc 检测代码中循环中包含 function 定义的。确实如果在一个循环中定义 function，so weird! 但是 js 没有块作用域，所以这样做意义感觉不大。http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html在重新读了函数声明和函数表达式后，函数声明不应该出现在块中。 属性操作IE问题setAttribute .属性操作 IE 问题 http://w3help.org/zh-cn/causes/SD9006 jquery $.prop() 与 $.attr() 如果设置 checked 这类应该使用 prop，attr 不再支持。","link":"/2013/10/10/read-post/"},{"title":"前端三俗之Promise","text":"这篇文章很好的介绍了Promise http://www.html5rocks.com/zh/tutorials/es6/promises/ 前端乱炖上有篇文章介绍了它的简易实现 http://www.html-js.com/article/1850 作为一个俗人，怎么会不用自己的逻辑再实现一遍呢。因为defer更为常见，就说说defer吧123456789101112var d = new Defer(function (resolve, reject) { setTimeout(function () { resolve('start'); }, 1000);});d.then(function (x) { console.log('then --' + x) return 'filter';}).then (function (value) { console.log('then ----' + value); return '***';}); 完成上面的功能，分析一下我们需要实现的有这么几个方法：then resovle reject。then做的事情就push回调，resovle reject就是唤醒处理。123456789101112131415161718192021222324252627function defer (func) { var observers = []; var state = 0; function then (onFulfill, onError) { observers.push([onFulfill, onError]); return this; } function exec (result) { while (observers.length) { var observer = observers.shift(); observer[state](result); } observers = null; } function resovle (x) { state = 0; exec(x); } function reject (x) { state = 1; exec(x); } func(resovle, reject); return { then: then }} 这个屌丝版defer还有几个问题： 调用then的时候可能已经执行过resovle了，需要重新执行一次。 没有考虑返回值是Promise的情况 值没有传给下一个then处理 处理一下这几个问题后：1234567891011121314151617181920212223242526272829303132333435363738394041424344function defer (func) { var observers = []; var state = 0; function then (onFulfill, onError) { if (observers) { observers.push([onFulfill, onError]); } else { observers = []; observers.push([onFulfill, onError]); exec(); } return this; } function exec (result) { while (observers.length) { var observer = observers.shift(); if (typeof observer[state] !== 'function') { continue; } try { result = observer[state](result); if (result &amp;&amp; typeof (result.then) === 'function') {//返回的是defer return result.then(resolve, reject); } } catch (e) { state = 1; result = e; } } observers = null; } function resovle (x) { state = 0; exec(x); } function reject (x) { state = 1; exec(x); } func(resovle, reject); return { then: then };} 看上去虽说屌丝，不过好像功能还行，而且逻辑很简单。但是跟标准有点不一样：defer.then().then() 和 defer.then(); defer.then() 按照标准是执行结果是不同的。如果按照上面的代码逻辑，处理的结果却是一样的，因为 then 只是简单的返回了 this。这儿的 then 应该返回一个新的defer对象。大概是这样子: 12345678910111213141516171819202122232425function defer () { var observers = []; function then (onFulfil, onError) { var deferred = new defer(); function resolve (value) { var ret = onFulfil ? onFulfil(value) : value; deffrred.resolve(ret); } function reject (value) { var ret = onError ? onError(value) : value; deferred.reject(ret); } observers.push({resolve: resolve, reject: reject}); return deferred; } function resolve (value) { } function reject (value) { } return { then: then, resolve: resolve, reject: reject };} then 返回的是一个新 deferr 对象, 而 observers 保存的是包装过的函数，调用这个函数的时候会调用传的回调，并使用返回值调用新 deferred 的 resolve 方法。 再看下 resolve 和 reject，这次我们将所有的返回值都当成 derfer 来处理，然后调用 then 方法。不难理解下面这段代码：12345678910111213141516171819function resolve (value) { result = isPromise(value) ? value : {then : function (resolve) {resolve(value);}}; while (observers.length) { var observer = observers.shift(); result.then(observer.resolve, observer.reject); } observers = null;}function reject (value) { result = isPromise(value) ? value : {then : function (resolve, reject) {reject(value);}}; while (observers.length) { var observer = observers.shift(); result.then(observer.resolve, observer.reject); } observers = null; resolve({then: function (resolve, reject) {reject(value);}});} 我们可能看到reject与resolve非常相像，可以完全用resolve替代，稍微改下：123function reject (value) { resolve({then: function (resolve, reject) {reject(value);}});} 该文章只是描述实现defer的思想，代码不能直接用，只是希望大家能一看就明白这个思路。 全部代码见https://github.com/fedeoo/codebrick firefox_raw_promise.js是firefox下的实现,比较具有参考意义。","link":"/2014/03/29/promise/"},{"title":"前端公共资源完全共享的畅想","text":"在每个前端项目中，多多少少都会依赖一些第三方资源，比如Query，React，Angular，core-js，babel-runtime；如果我们能够尽最大程度的复用这些资源，那么我们就能够节约很大的首次请求成本，无需绞尽脑汁即可显著提升首屏首次加载速度。另外提升 webpack 构建速度，扯这么多构建优化方案，就设置 externals 效果最显著； 问题由来前端资源如果可以尽可能的使用公共 CDN 上资源，但是集团内的公共资源太少，只有一些主流的框架或库，这就导致各个团队可能会维护一份自己的公共资源 CDN。现实中使用这些 CDN 略微麻烦，比如新起一个项目就需要这么以下步骤： 看下项目中依赖的哪些流行库可以在 CDN 上找到，譬如 react，先把这个脚本插入在页面模板。开发环境需要一些警告信息，所以最好不要使用压缩脚本。 12&lt;script src=&quot;//cdn.bootcss.com/react/15.0.1/react-with-addons.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;//cdn.bootcss.com/react/15.0.1/react-dom.js&quot;&gt;&lt;/script&gt; 生成环境的模板需要压缩过的脚本： 12&lt;script src=&quot;//cdn.bootcss.com/react/15.0.1/react-with-addons.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;//cdn.bootcss.com/react/15.0.1/react-dom.min.js&quot;&gt;&lt;/script&gt; 因为我们是使用 webpack 构建，所以，还需要配置 externals；形如 1234567externals: { react: &apos;React&apos;, &apos;react-dom&apos;: &apos;ReactDOM&apos;, &apos;react-addons-css-transition-group&apos;: &apos;React.addons.CSSTransitionGroup&apos;, &apos;react-addons-shallow-compare&apos;: &apos;React.addons.shallowCompare&apos;, &apos;react-addons-transition-group&apos;: &apos;React.addons.TransitionGroup&apos;,}, 在上面 react-addons 的资源如果不指明，很可能出现某个第三方的组件库引入 react-addons，导致 react 依旧被打包在一起。 维护需要人工成本。 如果哪一天要升级 react 版本，看到 CDN 上有新版本，还要把模板引用的版本号给改掉。 使用工具消灭重复劳动如果我们使用用 webpack 为什么不用一个插件解决这些呢？但是，但是这儿有一个问题：cdn 资源没规则，从 package.json 中完全看不出； 模块的依赖有可能已经打包在一起；如 react-router，将 依赖的小文件一起打包。 依赖不明确；如 bootstap 依赖 jquery 是在 dependencies 中指定的，而 react-router 其实只需要外部的 react，在 peerDependencies 中声明的。 现有的资源路径规则也不确定，如 bootcdn.cn 上 min.js 存在 -min.js 和 .min.js。 好吧，那我就自己维护一份，cdn-webpack-plugin 就是这个插件的雏形。为主流构建工具提供插件，也能够推动资源的共享。 理想与现实理想如果实现了，那前端资源无需 npm install，直接引用 CDN 就可以了。另外我们还能够做一些优化：根据资源共同出现频率选择合适的资源 combo如：react 全家桶 用到 redux 系列， redux react-redux react-thunk。 现实是，我们不可能维护所有资源的所有版本，不可能取代 npm 或 yarn。也不会如它们这么及时，一个第三方库 fix bug 升级，不大可能立即同步到 CDN 上。最大的问题还是第三方的资源不可信，除非几个大公司牵头组织一个第三方的资源库。","link":"/2017/01/02/前端公共资源完全共享的畅想/"},{"title":"谈谈组件封装","text":"在前端开发中，我们往往会定义自己的组件，比如常见的日期选择器 datepicker，在其它页面上需要使用时再实例化一个组件。本文简单地聊下组件封装。首先会说下基于 jquery 的封装，之后会以 angular 为例，简单说下框架与组件的适配。最后说说 web components 标准。 jquery 类组件封装一个组件，往往需要提供的方法有 init： 负责构造组件 DOM 结构，之后会做一些事件绑定。这个接口往往还会接受一个options类的配置数据。 render： 根据状态数据渲染组件。往往是重绘模板。 onchange： 对外暴露一些事件。 setValue：改变内部数据接口，重绘最简单的方式就是再次 render。 destroy: 处理组件销毁工作，比如 unbind event。 然后像下面这样实例化一个组件（假设是 jquery widget）。 1$('ele').datepicker({...}); 不过，很多时候我们不想手动去实例化一个组件。我们觉得下面这种写法更符合 web 语义。 123&lt;div data-role=\"date-picker\"&gt;....&lt;/div&gt;&lt;date-picker onchange='****'&gt;&lt;/date-picker&gt; 如果我们使用一些配套的框架，往往也会支持这种写法（如 Bootstrap…）。在 DOM 加载完成之后，扫描所有节点，对支持组件的节点，调用对应的组件构造方法。如果在框架加载处理完成之后，自己手动插入组件节点，是不会生效的，往往还需要手动 init，销毁时的还要手动销毁。通常所有的组件还会继承自一个 BaseComponent，该 BaseComponent提供一些公共的方法。 angular.js 1.× 中的 directivedirective 是 angular 的三大特性(mvvm，依赖注入，directive)之一。 angular 在 do-bootstrap 之后，最后会编译根节点并 link 到 rootScope 上。 1compile(rootElement)(rootScope) 简化再简化版伪代码描述： 123456789101112131415161718192021222324function compile ($compileNodes) { return compileNodes($compileNodes);}function compileNodes ($compileNodes) { _.forEach($compileNodes, function (node) { var directives = collectDirectives(node); applyDirectivesToNode(directives, node); // 递归compile子元素 compileNodes(node.childNodes); });}function collectDirectives (node) { var directives = []; // 查找 nodeName attributesName className 中的directive 并加入directives ... return directives;}function applyDirectivesToNode (directives, node) { // 以node为参数调用所有diretives的compile方法 _.forEach(directives, function (directive) { directive.compile(node); });} link 与 compile 对应但又分开。考虑 ng-repeat 这样的 directive， 只需要一次 compile，而 link 次数就不确定了。还有很多需要考虑的，如 scope 层级、独立 scope、属性上的双向绑定…. react.js 对 react 不熟，就看看吧。 简单的组件 React 写法看上去没有什么不同。看上去好像也是提供一个模板，数据变化时重新渲染。代码中的标签写法是 jsx 语法，实际会处理成 reactElement。 12345678910var XXXComponent = React.creatClass({ render: function () { return ( &lt;div&gt; // 根据props state数据填充 .... &lt;/div&gt; ); }});React.render(&lt;XXXComponent&gt;, element); 每次都重新渲染的方式，有点太过简单暴力。虽说性能可能会有影响，但是开发者完全不需要关注数据变化是怎么改变组件（之前可能会介绍选择局部重绘）。react 引入的 virtual DOM 使得重绘非常高效（传说这样子），就更不用担心。 如果根据react的diff算法设计场景故意让重绘效率降低 表单验证这方面就不如 angular 的写法优雅。假如对一个 Input 添加一个新的验证，React 就必须用一个采用 Wrap 的方式，当然也可以重写一个 Input 支持 xxx 属性。 123456&lt;!-- react 写法 --&gt;&lt;XXXValidator&gt; &lt;Input/&gt;&lt;/XXXValidator&gt;&lt;!-- angular 写法 --&gt;&lt;input xxx-validator /&gt; web components上面讨论的做法不管怎样封装，实际 DOM 结构都会暴露在外，而且样式冲突防不胜防。而 web components 提供的 shadow DOM 做到了完全隔离组件。比如现在很常见的 range 组件，对外看起来就是只有一个元素，遍历时也获取不到 range 中的子元素，而且外部的样式也不会影响到组件。1&lt;input type=\"range\"&gt; 考虑到确实有这样的场景，需要自定义组件样式，需要自定义组件内容，如 Dialog 这种。shadow DOM 提供了通透的那部分对外又是可见的。使用伪元素选择器又能改变组件样式。 前年有翻译规范的打算。后来读的时候不能完全明白，实在翻译不下去了… 小结整篇文章先说常规的组件封装。再谈语义化更为明确的 direactive，只说了框架与组件的适配，中间插入最近比较火的 react 组件，最后以 web components 标准结束。最后还想说下基础组件与业务组件，基础组件一般不会变化。做一个项目时，有时发现几个功能类似需求出现在几个地方，封装成一个组件。过段时间需求变更，其中一个地方需要加新功能…。这么来几次，一个业务组件很容易被玩坏。业务组件如何复用是一个麻烦的问题。","link":"/2015/05/14/talk-about-component/"},{"title":"前端框架的最佳实践（AngularJS 和 React）","text":"对框架的使用者来说，谈一个框架的思想，其实不如谈谈它的最佳实践。就是同一个框架，不同的人实现相同的功能，代码也是千差万别。不同风格的实现自然也有高低之分，而往往这些东西还没有成文的规定，不知道坑了多少前端。这些框架还有另一个特点—–非常容易上手（入坑），从而埋下更深的祸患。这么简单！其实往往是不明所以的时候就开始挖坑了。 2015年初时计划切换框架，因为一直在做的都是管理后台类项目，所以理所当然地投奔到 AngularJS 阵营了。在做切换到 AngularJS 时，需要有一个思维上的转变，原来对 DOM 的操作要转为操作数据，数据发生变化了，界面就会跟着变化。用过 AngularJS 的同学估计都记得一些建议和警告： 不要使用 jQuery (不合时宜地操作 DOM) 尽量避免 global scope 保持瘦 Controller …(快一年没写了，不记得了–!) 其中一些很容易理解，表示的很清楚，这些还好（表示还是都见到 😞 ）。另外一些就很难说了，比如： ng-init 这个标签，有人不顾警告地使用，我是万万没想到，Controller 初始化的部分逻辑要看模板才知道。 类似的情况，实现一个 directive 做拉取数据的逻辑。复用代码的方式有很多，何必这样呢？你这样做数据流还怎么管理？告诉我！ 模板里面写很长很长的表达式。对于模板，一定不要做太多事，一定不要写太多逻辑。流过这么多泪之后，个人非常推崇 Logic-less template。后来在 React 中有人吐槽 JSX {} 中不能写 if 语句，只想说你们真没痛过么？ 关于 AngularJS 现在想起的也就这么多了，项目搭建好后，后端也能撸代码。不过，你得遵照一点要求：取数据在一层；处理数据在 service；controller 简单的调用函数，挂数据在 scope 上；模板保持简单。后端 MVC 中不是也要 保持瘦 controller 的，逻辑丢在 service 么，你前端写这么乱，感情你后端代码也是一粪池？ 最开始接触 React 是在 2015 年，最开始的印象是： JSX 好奇怪，只是做了渲染。今年年初接触 React 时，看到当时项目时，感觉怎么比 AngularJS 还麻烦还难读。当时是纯 React，不难想象到代码结构，一个组件负责一个页面，拉取数据，处理数据，显示对话框，各种逻辑都在里面，数据都在 state 上，一个文件七八百行不成问题。于是想拆，按照 Angular 的思想，取数据和处理数据，总该挪出去吧。可是文件还是很大，于是想找找类似的最佳实践。首先是官网的 thinking in react ，你这是逗我么？这简直是 react hello world。 数据流这么乱，先套上 redux 吧（发明 flux 的人一定是被 AngularJS 的数据流搞懵逼过）。在 redux 中倒是有了一点发现，react-redux 入门文档说 深受 分离容器组件和展示组件 思想启发。姑且叫这么个中文名吧。之后翻译了 React.js 初学者应该知道的 9 件事，开始明白纯渲染组件的好处，官网的文章也不是在逗我。 React 开发最佳实践（一句话攻略）就是：写简单可靠的纯组件，然后使用搭积木的方式组合这些小组件搭起一个页面。 之后当有新人要上手做项目时，关于 React，我真不知道要说些什么。那就说说 redux，要怎么写，怎么维护数据流，保证你的组件简单。对于新人来说，上手也确实容易，最开始甚至不需要搞清楚数据流那一套，只需要告诉他怎么写怎么写就可以了。 功能实现很简单，当我看代码时，总是觉得别扭，我不会这么写。第一个问题是，用继承复用相同逻辑，可是如果我来写的话，只会想到组合，因为逻辑相同的是父容器呀。后来，又有同事问可否有多个父类，我很好奇是什么场景，为什么不用组合。因为这么久的项目只有极个别的地方用到了继承。尽量选择组合，官网也是一样的态度，可以看下官网上 组合与继承 最后一段话。Mixins 毫无疑义被 HOC 取代，react-redux 中的 connect 就是 HOC 一例。相关文章 Mixins Are Dead. Long Live Composition （还是他的） 优先组合这个还好说，如何抽象一个组件这个就麻烦了，现实中比较多碰到的是，组件很庞大，越写代码越长，每个组件都尽量拆成纯函数组件不是每个人都能（愿意）做到的。功能都实现了，上线了再说，谁还管这个啊。随便翻翻 github 上的 React 组件库，一个组件几十个属性，代码五百行起的超级组件，你让我怎么看啊！ 最后一个小问题也是跟组件抽象有关，没有仔细思考组件的输入和输出。说好听点是封装组件的时候欠斟酌，不好听的话是欠缺抽象封装组件的能力。表象是往往丢给一个组件不需要的属性，或者不需要的多个属性，这个组件其实依赖的是一个处理完成的一个名字，而不是把几个揉在一起。对这类问题，想象一下这个场景，团队中的另外一个人想复用你的组件，你还会暴露这么些属性和方法么？这类问题太常见了，自己调自己的业务组件，想这么多还上线么？ 说 React 容易的人，大多是在忽悠人入坑，就像忽悠别人学前端一样。我至今还是不知道怎么教新人写好 React ，这个真心不好教啊。 对于新人，我只能说：前面坑多，少一点浮躁，沉下心来学一段时间再说话。 很早就想写一篇这样的文章，拖了很久，关于 AngularJS 的部分忘太多了。新年第一篇 🎉 🎉 🎉","link":"/2017/01/01/前端框架的最佳实践（AngularJS-和-React）/"},{"title":"一点思考","text":"整篇文章的思路是这样子的：重新思考前端开发过程，有不少让人觉得不痛快的地方。如果没有这些束缚的话，理想中的开发部署又是怎样的？理想有点远，眼下我们又能做些什么呢？ 现状与问题最近在重新思考前端构建与部署，不过上次写的文章根本没有讲清楚。没有讲清楚为什么要这么做。现在我们来重新审视下目前流行的前端技术栈与发布方式，以我熟悉的技术栈为例。 项目启动：一般团队都会有自己的脚手架，再不济也可以 copy 现有项目，迅速搭建开发环境。 开发与调试：集团内比较常见的或许是 React + Redux，集团外或许是 Vue 构建与部署：云构建发布到 CDN 上，修改后端维护的版本号。构建工具基于 webpack。 我们再来看看问题： 脚手架的问题之前也提到过，没有一个像样的更新工具，用 generator 生成之后只能手工升级。 开发中的问题很多，与技术栈关联也比较大。我觉得有个问题值得反思一下，现在很多的框架号称半小时搞定增删改查，为啥前端还是忙的没时间，甚至有些觉得开发速度不比 jQuery 来的快。 计算资源的浪费。以 React 应用为例，对于纯静态的内容，每次重新渲染这不是纯粹浪费么，不管在服务端还是客户端这些浪费都是不能容忍的。前后的资源消耗统一来看的话，怎么看都是服务端模板渲染更为节约。 带宽的浪费。每个项目都用到了那么多的公共库，webpack 一并打进去，每个应用每个版本都有大量的请求都是非必须的。而且集团很多的变更，都是一个版本的粗粒度的控制，每次版本变更，所有的资源又重新拉取一次。 构建的问题。webpack 取代 gulp，改变了我们管理资源的方式。webpack 很复杂，它的配置我们应该关心吗？我们把构建理解为一个黑盒，源文件作为输入，目标代码作为输出。我多希望我什么都不用关心，构建就能正常运行起来。 部署优化。pagespeed 已经提供了一个性能诊断，甚至可以给出一个优化方案，为什么我们还要自己上手来搞这些。 大胆思考上次也接着贺老的思路 YY 了一番，这儿再啰嗦一遍： 资源云化。所有可以公用的资源都在云上，可以说是公用 CDN 资源的高级形式。这个可以解决问题4。 几乎不需要配置，构建可以自动完成，并且它可以做些分析，还可以做些优化。 现成的部署和监控方案，根据请求响应不同内容。比如首屏的关键路径样式优化，预加载，这些由服务器自动优化。 上面的 2 和 3 听上去都有些智能的感觉。还有一个问题是：我们进行了太多重复不必要的运算，就像上面的问题3，每次重新运行 webpack 我都觉得是种浪费。 脚踏实地步子迈的太大，有点不切实际。我们先利用好手上可用的工具来解决性能和资源问题。不对现有技术体系做大的调整下，利用新的技术做些优化。 对上面的问题3，我们还有服务端渲染嘛，只是服务端渲染的机会成本略高。退一步我们可以考虑，数据直出，预渲染。create-react-app没有引入服务端渲染的特性，倒是提到了预渲染 React Snapshot 。这个库的思路是：服务端渲染太麻烦，不如生成静态页面。react-snapshot 提前渲染这些页面，重新生成一个静态页面。 增强构建。PWA 很诱人，无需大的改动，我们可以使用webpack 插件 可以帮助生成 servicework.js 文件。若有必要我们可以使用 http2-aggressive-splitting 分割文件来加快 HTTP2 网络下的资源加载速度。还有 preload-webpack-plugin 插件帮助做预加载的脚本。 后记追随框架与工具变革却看不清未来发展趋势，整理下最近的想法。","link":"/2017/06/26/一点思考/"},{"title":"就一个静态页面","text":"周二晚上邮件收到一个需求：下周有个活动页面，就一个静态页面。打开设计稿一看，一个秒杀活动页面，与设计对了一下，发现有个动画要做。之后需求方描述了一遍：倒计时结束，按钮可点，跳转到订单页面。后来，开发一对需求，发现秒杀后面的很多逻辑都没考虑： 时间同步问题 验证码问题 订单有效期 是否影响正常售卖 其它业务逻辑问题… 就目前情况考虑，参与活动的人并不多，而且事急从权，可以简单处理。 时间就先取服务器时间。 验证码，先找个 npm 包 ccap，随机生成一段文本和对应的图片。服务器端在返回验证码图片时，将原文本保存在 session 中。创建订单时检测验证码与 session 中的信息是否匹配。那么问题来了，我们的服务器肯定不止一台，session 是怎么同步的？看看 session 模块好像没有这些逻辑啊，最后 session 是使用了 tair 同步 session。验证通过之后，应该清除 session 中的 验证码信息。如果验证请求是同时发出的，读取 session 内容比较，肯定都是通过的，这就有问题了。也就是说，读 与 清 必须是一起的。这就得用锁了，读取的时候加锁，完成后，释放锁。做完这些，验证码这块还留有问题，上面提的那个 ccap 包，每次重新创建图片的方式肯定太慢，最好是提前生成一批，定期更换。 订单有效期的问题：后端需要一个任务定时检查订单是否过期释放库存。 正常售卖最好与秒杀分开，就算秒杀出什么问题，也不影响正常售卖。 实际的秒杀活动中，为了减少服务器压力，在请求的最开始就直接随机拒掉一批请求了。所以，手黑是有原因的。 这就是需求方说的：就一个静态页面。","link":"/2016/05/15/就一个静态页面/"},{"title":"移动端视频播放的另一种方式","text":"前几天做的一个移动端页面需要播放一段视频。嵌入页面video标签的方式肯定是不合适的。 因为页面需要的其实只是一个动画效果，对音频没有要求，所以就有机会选择其它的方式解决。最先想到的方案是 canvas-video，前不久 BM2 炫酷的微信广告就是用它实现的。原理很简单： 123let context = canvas.getContext('2d');// 在视频播放时，从video中取出图片，在画布上 drawImagecontext.drawImage(video, 0, 0, width, height); 整个库除了做播放控制之外，还值得提的就是绘制时使用 requestAnimationFrame 优化，这儿就不多说了。效果实现之后，在自己手机 iOS 上看下效果，video 可以自动播放，虽然不能循环，效果还行。找了台安卓机测试发现，效果出不来，因为移动环境下的流量保护禁用自动播放。 然后在 github 上发现一个 canvid 项目用来解决移动端视频播放，它的方案是：将视频中的关键帧抽取出来，合并为一张图片，使用 canvas 播放图片。这个方案的浏览器支持肯定是没有问题的，问题是效果和加载速度如何。准备图片倒是折腾了一会，给的两个工具安装后直接使用报错，需要根据报错提示安装依赖的工具（两次）。之后的实现就很简单了，视频播放效果还很流畅。注意播放帧的设置，从源视频抽取图片时，是每 5 帧抽取一张图，这儿设置每秒 13 帧，与视频的每秒65帧是同步的。 现在的问题就是合并之后的图片太大了。canvid 有提醒：图片大小在一些移动端存在大小上限。后来把原图片分为 4 张图进行合并，每张大小在 700k 左右（无法再做压缩，ImageMagick 合并图片时已经做了压缩）。该库会在所有图片加载完成之后进行播放，在这儿我们可以进行一些简单的优化，在第一张图片加载完成之后就可以播放动画，播放时可以继续加载后面的图片。 为什么这种方式优于 gif 呢？因为 gif 是无损压缩，jpg 是有损压缩，压缩比差距很大。 那如果我把图片有损压缩处理之后，再转成 gif 格式呢？效果还是不如 jpg，因为 jpg 可以对这些图片的共同部分进行压缩。 当然最好还是使用视频格式，因为视频在播放的时候无需全部加载完成，而且在之后的数据传输可以传入差异数据。 最后，放下效果页面","link":"/2016/05/07/移动端视频播放的另一种方式/"},{"title":"探秘 MobX","text":"MobX 是最近在 React 社区比较火的状态管理工具。与 Redux 相比，Mobx 简单又神秘。不止是因为 MobX 比较火，MobX 的双向绑定与 Vue 的实现也是非常相似，十分有必要去了解一下双向绑定的实现。这篇文章通过源码解释 MobX 这些奇怪的“特性”。就像 Redux，MobX 跟 React 也没有关系，我们从最最简单的例子开始。MobX 版本 3.1.7 observable123const store = observable({ title: 'front end developer',}); observable 返回一个新的对象 ref，包含一个 $mobx 属性，$mobx 是一个 ObservableObjectAdministration 对象。这个对象稍微有点复杂，不过其实就是 Object.defineProperty 拦截 getter 和 setter，我们暂不需要弄懂 getter 和 setter 究竟做了什么事情。values.title 是一个 ObservableValue 对象，我们大概可以猜到它的属性 observers 存放了观察 values.title 变化的对象。123456789101112131415161718192021222324252627{ title: 'front end developer', $mobx: { // ObservableObjectAdministration name: 'ObservableObject@1.user', target: ref, // 指向新返回对象 values: { title: { // ObservableValue value: 'front end developer', name: 'ObservableObject@1.title', observers: [], get() { this.reportObserved(); return this.value; }, set: function(v) { setPropertyValue(this, propName, v); }, }, }, }, get title: function() { return this.$mobx.values[propName].get(); // 这儿的 propName }, set title: function(v) { setPropertyValue(this, propName, v); },} 上面只是一个最简单的对象，如果对象复杂点，也会递归的包装对象。 autorun在一个函数中简单输出 store.title，我们跟踪下 autorun 方法。123autorun(() =&gt; { console.log(store.title);}); autorun 方法会使用传入的参数创建一个 Reaction 对象 reaction， 然后调用 reaction 的 schedule 方法。1234567891011121314151617181920{ name: 'Reaction@2', onInvalidate() { function reactionRunner() { view(reaction); // view 传入的匿名函数 } this.track(reactionRunner); }, observing: [], newObserving: [], dependenciesState: IDerivationState.NOT_TRACKING, __mapid: '#3', diffValue: 0, runId: 0, unboundDepsCount: 0, isDisposed: false, _isScheduled: false, _isTrackPending: false, _isRunning: false,} schedule 方法将 reaction 添加到 pendingReactions，最后执行每个 reaction 的 runReaction 方法。123456789runReaction() { startBatch(); this._isScheduled = false; if (shouldCompute(this)) { this._isTrackPending = true; this.onInvalidate(); // 这个就是初始化用匿名函数构造的一个方法。 } endBatch();} onInvalidate 调用 track， track 调用 trackDerivedFunction，跟踪下 trackingDerivation123456789101112131415function trackDerivedFunction(derivation, f, context) { // ... derivation.runId = ++globalState.runId; const prevTracking = globalState.trackingDerivation; // 保存当前 trackingDerivation globalState.trackingDerivation = derivation; // 设置全局 trackingDerivation let result; try { result = f.call(context); // 执行我们传入的匿名函数，newObserving } catch (e) { result = new CaughtException(e); } globalState.trackingDerivation = prevTracking; bindDependencies(derivation); // 重新收集依赖 return result;} 这个函数在执行我们的匿名函数之前，设置全局 trackingDerivation 为当前的 reaction ，执行之后又设置回原来的变量。在我们的匿名函数中打印 store.title，回想下最开始 ObservableValue 对象在解析 store.title 值时会调用 reportObserved 。1234567891011function reportObserved(observable) { const derivation = globalState.trackingDerivation; if (derivation !== null) { if (derivation.runId !== observable.lastAccessedBy) { // 简单优化 observable.lastAccessedBy = derivation.runId; derivation.newObserving[derivation.unboundDepsCount++] = observable; } } else if (observable.observers.length === 0) { queueForUnobservation(observable); }} 这儿的 derivation 就是我们的 autorun 创建的 Reaction 对象。到现在我们瞧出了一下端倪，在一个 Reaction 环境中解析值，则该 Reaction 依赖该 observable 对象。注意这儿并没有直接放到 observing 数组中！执行完当前方法之后，在 bindDependencies 才重新设置了 observing。这一步是必需的，考虑下 autorun 中有条件语句的情景，除了条件语句，如果我们的对象稍复杂点，譬如 store.user.title，我们对 store.user 重新赋值就会改变依赖的 observable。最后分析下下面的代码片段，猜测输出几次：1234autorun(() =&gt; { console.log(store.title); store.title = 'hello world!';}); 你会发现输出一次，因为初次执行时reaction.observing 为空，执行完之后才会根据 reaction.newObserving 更新 observing。再在外面修改 store.title = ‘changed title’，这次就会正常的输出 changed title 然后输出 hello world! bindDependencies 设置新的 observing 后，还同步更新依赖的 ObservableValue 的 observers，store.title 被哪些依赖到需要更新。在 store.title 发生变化时，setPropertyValue 会触发 propagateChanged 方法12345678910111213function propagateChanged(observable) { if (observable.lowestObserverState === IDerivationState.STALE) return; observable.lowestObserverState = IDerivationState.STALE; const observers = observable.observers; let i = observers.length; while (i--) { const d = observers[i]; if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale(); // call shedule d.dependenciesState = IDerivationState.STALE; }} observable 变化时，调用 observers 中每个对象的 onBecomeStale 方法，对 Reaction 对象来说 onBecomeStale 简单的调用 shedule；对 ComputedValue 对象来说则会执行 propagateMaybeChanged，这儿有些优化如果 Reaction 对象状态不是已经更新（ UP_TO_DATE），什么都不做。为说明这个问题，我们造一个例子：123456789101112const store = observable({ a: 3, b: 4, get sum() { return this.a + this.b; },});autorun(() =&gt; { console.log(store.sum); store.b = 5;});store.b = 6; 上面这个例子只输出一次，注释掉 autorun 中的 store.b = 5 赋值语句，结果当然会输出两次。如果该赋值语句丢在另一个 autorun 中则会输出四次。不知道该如何解释。 结语MobX 的反应系统不难理解，从图中的线条就能看出来。分析源码可以帮助我们搞明白在pixel paint这个例子中为什么它会这么高效，在以后的项目中我们也可以受到启发。双向绑定主要是依赖收集，理解起来比较简单，但是关于性能优化部分的分析本篇文章没有提及，有兴趣的同学可以深入研究一下。","link":"/2017/03/30/探秘-MobX/"},{"title":"js 模式--一般模式篇","text":"读石川js模式，以下出自：http://shichuan.github.io/javascript-patterns/ 有些代码只是部分复制，另外加注的是自己的一点愚见。原文中的preferred 翻译为建议 、倾向于、宁愿。 1 函数声明 创建匿名函数赋给变量1234567891011121314//anti-pattern 反面模式function getData() {}//倾向于//好处：1.更容易理解‘函数即对象’ 2.促使使用;习惯 3.不再有函数和作用域感情包袱var getData = function () {};//命名函数表达式//优点：1.debuger时有显式的函数名称 2.允许递归调用//问题：can break IEvar getData = function getData () {}; 注：如果需要递归，使用arguments.callee也很方便，且在重命名函数名称时，不需要在第二处修改。123//下面这种方式避免了上面的问题var getData = function getDataF () {}; 注：typeof getDataF === ‘undefined’ IE8及以下的标示符泄露， typeof getDataF === ‘function’ 2 条件123456789101112131415161718192021//正常模式if (type === &apos;foo&apos; || type === &apos;bar&apos;) {}// 方法1 - regex testif (/^(foo|bar)$/.test(type)) {}// 方法2 - object literal lookup (smaller if &lt; 5 items)if (({foo:1, bar:1})[type]) {}// 方法3 二分查找//方法四 对象数组查找表//对单键值对的尤其适用// define the array of resultsvar results = [result0, result1, result2];// return the correct resultreturn results[value];//方法5 使用逻辑操作符 注： 看上去好高端又节省代码 3 访问全局对象123var global = (function () { return this || (1, eval)(&apos;this&apos;);}()); 注：表达式(1, eval)，严格模式下规定引用类型的eval作用在全局。 4 单一var模式12345678910111213//使用一个var声明多个变量//优点： 1.提供了查找函数需要局部变量的唯一的位置 2.防止未定义先使用的逻辑错误 3.提醒你声明变量，防止误声明为全局变量 4.字符数较少//把逗号放在变量前 避免忘记function func() { var a = 1 , b = 2 , sum = a + b , myobject = {} , i , j; // function body...} 注： 对于习惯其它强类型语言人来说，这种写法是绝对不赞同的。还记得C中的 int * a,b;声明的其实是一个指向整型的指针变量和整型变量。我个人是不在乎多写几个字符。另外将变量放在一处声明，个人也不是很赞同，尤其是函数比较长的话，你压根就不记得这个变量有没有声明了，在声明处看也看不出这个变量是干嘛的。（不记得是不是《代码简洁之道》中提的）比较赞同的写法是离最近使用的地方声明，比如，for循环中的i就该在for上面声明。 5 Hoisting 在函数中的var语句就相当于变量声明在函数顶部12345678// 反面模式myname = &quot;global&quot;; // global variablefunction func() { alert(myname); // &quot;undefined&quot; var myname = &quot;local&quot;; alert(myname); // &quot;local&quot;}func(); 上面的代码片段就相当于：12345678myname = &quot;global&quot;; // global variablefunction func() { var myname; // same as -&gt; var myname = undefined; alert(myname); // &quot;undefined&quot; myname = &quot;local&quot;; alert(myname); // &quot;local&quot;}func(); 注：虽然知道，但是感觉这种错误太容易犯了。因为倾向的代码风格使用var再次声明。 6 for循环 （注：copy不全）12345// 提供的倾向的方法1 使用单一varvar i, myarray = [];for (i = myarray.length; i--;) { // do something with myarray[i]} 注： 很多IDE都能够自动生成，下面是sublime text2自动生成的。123for (var i = Things.length - 1; i &gt;= 0; i--) { Things[i]}; 7 for in 循环12345678910111213141516171819202122232425262728293031323334353637383940414243// 定义一个对象var man = { hands:2, legs:2, heads:1};// 添加一个方法if (typeof Object.prototype.clone === &apos;undefined&apos;) { Object.prototype.clone = function () { };}// 反面模式// for-in loop without checking hasOwnProperty()for (var i in man) { console.log(i, &quot;:&quot;, man[i]);}// 建议方法 1for (var i in man) { if (man.hasOwnProperty(i)) { // filter console.log(i, &quot;:&quot;, man[i]); }}// preferred 2// benefit is you can avoid naming collisions in case the `man` object has redefined `hasOwnProperty`for (var i in man) { if (Object.prototype.hasOwnProperty.call(man, i)) { // filter console.log(i, &quot;:&quot;, man[i]); }}// preferred 3// use a local variable to &quot;cache&quot; `Object.prototype.hasOwnProperty`var i, hasOwn = Object.prototype.hasOwnProperty;for (i in man) { if (hasOwn.call(man, i)) { // filter console.log(i, &quot;:&quot;, man[i]); }} 注：一般的写法也就是方法1，没有考虑到hasOwnProperty会被重定义，重定义原始对象方法的都是二货。 8 不要增加内置prototypes//也有几个例外 1. 2. 3注： 你还想例外，还是当没有例外吧。. 9 switch模式123456789101112131415161718192021222324//提高代码可读性和鲁棒性 1.对齐case switch 2.缩进case内的代码 3.case以break结束 4.如果不需要break是更好的方法，确保有注释 5.以default结束/* Style conventions: * 1. Aligning each `case` with `switch` (an exception to the curly braces indentation rule). * 2. Indenting the code within each case. * 3. Ending each `case` with a clear `break`;. * 4. Avoiding fall-throughs (when you omit the break intentionally). If you&apos;re absolutely convinced * that a fall-through is the best approach, make sure you document such cases, because they might * look like errors to the readers of your code. * 5. Ending the `switch` with a `default`: to make sure there&apos;s always a sane result even if none of * the cases matched. */var inspect_me = 0, result = &apos;&apos;;switch (inspect_me) {case 0: result = &quot;zero&quot;; break;case 1: result = &quot;one&quot;; break;default: result = &quot;unknown&quot;;} 注： 还记得一同学写的一个计算日期相差天数的函数，里面的case都没有break;给有强迫症的人看真抓狂–！ 10 避免隐式类型转换12345678910var zero = 0;// 反面模式if (zero == false) { // this block is executed...}一直使用 === 或者 !== 检查比较的类型和值if (zero === false) { // not executing because zero is 0, not false} 原注：有时严格比较会比较多余，如大家都知道typeof 返回的是 string，所以就没必要使用严格比较。但是jshint需要严格比较，这让代码看起来更一致。注：我倒是赞同使用严格比较，但是为嘛老觉得需要严格比较多次呢，比如感觉经常需要判断是 undefined和null，以后得想下了。不记得在哪儿看的了，说代码中还是要区分undefined和null的，因为语义上讲，undefined表示该对象你压根没定义，null表示你可能是忘了赋值。 11 避免eval()123456789101112131415161718192021222324// 反面模式1var property = &quot;name&quot;;alert(eval(&quot;obj.&quot; + property));// 建议 1var property = &quot;name&quot;;alert(obj[property]);注：obj[&apos;name&apos;] 在jshint审查时会提示你使用obj.name，因为常量字符串/* 反面模式 2 * It&apos;s also important to remember that passing strings to setInterval(), setTimeout(), * and the Function() constructor is, for the most part, similar to using eval() and therefore should be avoided. */setTimeout(&quot;myFunc()&quot;, 1000);setTimeout(&quot;myFunc(1, 2, 3)&quot;, 1000);// preferred 2setTimeout(myFunc, 1000);setTimeout(function () { myFunc(1, 2, 3);}, 1000);// in supported browsers (i.e. not IE)setTimeout(myFunc, 1000, 1, 2, 3); 11 数字转换 parseInt()使用第二个参数在这个例子中，如果你省略了进制参数，如parseInt(year) 返回值可能是0 因为把09当做八进制数，而09又不是一个合法的八进制数。1234var month = &quot;06&quot;, year = &quot;09&quot;;month = parseInt(month, 10);year = parseInt(year, 10); //注：chrome下还是得到的还是9，提到数字，想起了前几天修的一个问题，在浮点数相加时。看着像bug一样。0.1 + 0.2 结果是 0.30000000000000004 toFixed(2) 12 尽量少用全局变量","link":"/2013/11/23/js-patterns/"},{"title":"【翻译】React.js 初学者应该知道的 9 件事","text":"原文地址：9 things every reactjs beginner should know 2016年1月份的文章，现在才翻译，又落后了半年 现在为止我使用 React.js 已经6 个月了。6 个月 放长远看一点也不长。但是，在 JavaScript 框架层出不穷的今天，6 个月可以称为老前辈了。最近指点了几个新人入门 React ，所以想总结一下写篇文章启发更多的人。下面总结的这些点，一些点是我希望在自己入门的时候就已经知道的，另外一些则是让我真正的理解 React。 本文假定你已经有了一下基本的概念。如果你不熟悉 component、props 或者 state 这些名词，你最好先去阅读下官方起步和手册。下面的代码示例我将使用 JSX 作演示，因为使用 JSX 语法写组件更为简洁，也更具表达力。 1. React.js 只是一个视图库我们从最基本的开始。React 不是一个 MVC 框架，好吧，它根本就不是一个框架。它只是一个渲染视图的库。如果你对 MVC 熟悉的话，你就会意识到 React.js 只对应了V 这部分，如果它插手了 M 或 C 的逻辑，你就需要考虑用其它方法来解了。否则，到最后，你的代码很可能会变成一坨翔。这部分后面会细说。 2. 组件尽可能的小这一点有些显而易见，但是有必要强调一下。每个良好的程序员都知道，较小的类、模块更容易理解、测试和维护，对于组件来说也是一样。我起初犯的错误是低估了 React 组件合适的大小。当然，合适的大小取决于很多不同的因素（包括个人与团队偏好），但是，一般来说，我建议，让组件明显小于你本认为的必需大小。举个栗子，我的个人网站主页上的这个组件，用于展示我的最新博文：12345678const LatestPostsComponent = props =&gt; ( &lt;section&gt; &lt;div&gt;&lt;h1&gt;Latest posts&lt;/h1&gt;&lt;/div&gt; &lt;div&gt; { props.posts.map(post =&gt; &lt;PostPreview key={post.slug} post={post}/&gt;) } &lt;/div&gt; &lt;/section&gt;); 这个组件本身是一个 &lt;section&gt;，里面只有两个 &lt;div&gt;。第一个&lt;div&gt;有一个标题，第二个&lt;div&gt;只是映射一些数据，使用数据中的每个元素渲染 &lt;PostPreview&gt;。还有一部分抽取&lt;PostPreview&gt;作为独立组件，这点很重要。我认为这是一个组件最合适的大小。 3. 写函数式组件首先，我们有两种定义 React 组件的方式，第一种是用 React.createClass()：12345const MyComponent = React.createClass({ render: function() { return &lt;div className={this.props.className}/&gt;; }}); 另一种是 ES6 class 写法：12345class MyComponent extends React.Component { render() { return &lt;div className={this.props.className}/&gt;; }} React 0.14 引入了一个新语法来定义组件，使用属性作为参数的函数：123const MyComponent = props =&gt; ( &lt;div className={props.className}/&gt;); 这是我最喜欢的定义 React 组件的方式。除了语法上简洁，这种方法还能帮助你界定什么时候需要拆分组件了。我们来回顾下之前的例子，假设下面是没拆分之前的代码：123456789101112131415161718192021222324252627282930class LatestPostsComponent extends React.Component { render() { const postPreviews = renderPostPreviews(); return ( &lt;section&gt; &lt;div&gt;&lt;h1&gt;Latest posts&lt;/h1&gt;&lt;/div&gt; &lt;div&gt; { postPreviews } &lt;/div&gt; &lt;/section&gt; ); } renderPostPreviews() { return this.props.posts.map(post =&gt; this.renderPostPreview(post)); } renderPostPreview(post) { return ( &lt;article&gt; &lt;h3&gt;&lt;a href={`/post/${post.slug}`}&gt;{post.title}&lt;/a&gt;&lt;/h3&gt; &lt;time pubdate&gt;&lt;em&gt;{post.posted}&lt;/em&gt;&lt;/time&gt; &lt;div&gt; &lt;span&gt;{post.blurb}&lt;/span&gt; &lt;a href={`/post/${post.slug}`}&gt;Read more...&lt;/a&gt; &lt;/div&gt; &lt;/article&gt; ); } 这个 class 还凑合。我们已经从 render 方法中抽取了几个方法，方法足够小，命名合理。我们来试着用函数式的语法重写一下：123456789101112131415161718192021222324252627const LatestPostsComponent = props =&gt; { const postPreviews = renderPostPreviews(props.posts); return ( &lt;section&gt; &lt;div&gt;&lt;h1&gt;Latest posts&lt;/h1&gt;&lt;/div&gt; &lt;div&gt; { postPreviews } &lt;/div&gt; &lt;/section&gt; );};const renderPostPreviews = posts =&gt; ( posts.map(post =&gt; this.renderPostPreview(post)));const renderPostPreview = post =&gt; ( &lt;article&gt; &lt;h3&gt;&lt;a href={`/post/${post.slug}`}&gt;{post.title}&lt;/a&gt;&lt;/h3&gt; &lt;time pubdate&gt;&lt;em&gt;{post.posted}&lt;/em&gt;&lt;/time&gt; &lt;div&gt; &lt;span&gt;{post.blurb}&lt;/span&gt; &lt;a href={`/post/${post.slug}`}&gt;Read more...&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;); 代码基本一样，无非是将类里的方法暴露为函数。但是，对我来说，区别可大了。在基于类的例子中，我看到的是class LatestPostsComponent {，自然而然会往下扫描闭合括号，然后在心中默想“在这儿这个类结束了，这个组件也到这”。对比函数式组件，我看到 const LatestPostsComponent = props =&gt; {，看到函数结束，就已经知道“这个函数结束，组件也在这结束”。“但是，等等，这个组件外面的代码是些什么鬼？还在同一个模块，哦，这是另一个函数，接收数据然后渲染视图，我把它抽取到出来就行了” 我就不再啰嗦函数式组件有助于我们遵循上面第二点。 以后，React 也会做一些优化，会使函数式组件比基于类的组件更为高效。（更新：函数式组组件的性能影响比我想象的要复杂。但是，如果性能不是大的问题，我依然推荐尽可能的写函数式组件，你应该好阅读下这个和这个，选择一个合适自己的） 还有个重要的店，函数式组件有几个 ’限制‘ ，我个人认为是大优点。第一个是它不会有 ref 赋给它，ref 在查找子组件并与之通信上非常方便，我的感受是 这是使用 React 的 错误方式。refs 鼓励一种非常直接，近于 jqeury 的方式写组件，远离了 函数式，单向数据流哲学理念，这些理念恰恰是我们选择 React 的初衷！ 另一个大的区别是函数式组件不会有状态依附，我下一个点就是讲… 4. 写无状态组件不得不说，到目前为止，我觉得写 React 应用，最让我头疼的事都是由包含很多状态的组件引起的。 状态让组件很难测试单纯的输入输出函数是最容易测试的，这点可以作为抛弃状态定义组件的理由吗？当我们测试很多状态的组件时，为了测试预期行为，我们必须先将组件设置为“正确的状态”。我们还必须考虑到所有的状态（因为组件可能在任意时刻改变这些状态）和属性（不受组件控制）组合，然后再去考虑那个组合需要测试，怎么测试。如果组件只是一个输入属性的处理函数，测试简直是不能更简单了。（关于测试，后面会讲）。 状态让组件很难推理（定位预期）当你读一段代码中包含很多状态的组件，特别费劲，你需要在脑海中记录组件的状态。这些问题：”状态有没有初始化？”，“如果我在这儿改变状态将会发生什么？”，“有几个地方改变了这个状态”，“这个状态是否存在条件竞争？”，这几个问题非常普遍。跟踪组件变化太蛋疼了。 状态让组件很容易引入业务逻辑我们不应该搜索组件然后才能确定行为。记住，React 只是一个视图库，所以，把渲染逻辑丢在组件里面没问题，但是业务逻辑也丢里面就有问题了。但是呢，如果你的应用状态都在组件里面，那在组件内部访问这些状态就会很方便，这样就会诱使你把业务逻辑也丢在里面。回顾下刚说的那点，这么做单元测试怎么办 - 没有业务逻辑你没法测试渲染逻辑，反之亦然。 状态让组件很难与应用其它部分共享信息父层组件的状态很容易传给下层组件，反过来就费事了。 当然，有时一个组件独立维护部分状态也是有必要的。在这种情况下，尽管放心使用 this.setState 。它也是 React 组件 API 合理的一部分，我并不想是让你觉得应该禁用它。比如，在用户输入时，不需要把每个按键都暴露给整个应用，应该保存自己的状态，在失去焦点之后，输入值会被派发到其它地方存储起来。这种场景是最近一个同事提到的，我觉得这个例子非常恰当。 为组件添加状态还是需要慎重。一旦你开始了，就很容易再加一个状态，不知不觉就不受你控制了。 5. 使用 Redux.js上面第一点就已经说过，React 只是一个视图库。那么问题来了，“状态和逻辑放哪儿？” 我很高兴你会这么问！你可能已经知道 Flux ，一种设计 web 应用的模式，在 React 开发中较为普遍。已经有几个基于 Flux 思想的实现，但是毫无疑问我推荐使用 Redux.js 。 我在考虑写一篇单独的博客，关于 Redux 的特性和优点。目前我推荐你读下官方文档，在这儿我只简单描述下它的工作原理： 组件上的 UI 事件触发时，它们执行属性上传入的回调函数。 这些基于事件创建的回调函数派发 actions Reducers 处理 actions 并计算新的状态 整个应用的新状态流入单一的 store 组件接收新状态作为属性，在需要时重绘 上面的这些概念并非 Redux 独创，但是 Redux 的实现比较清晰简单。从 Alt.js 切换到 Redux ，减少了很多代码量，这儿简单列出比较突出的优点： reducers 是纯函数，简单的 oldState + action = newState。每个 reducer 只处理一部分状态，这些状态可以组合起来。这么做，所有的业务逻辑和状态转换很容易测试。 API 很少，很简单，文档清晰。非常容易学习这些概念，因此很容易理解项目中 actions 和 数据 的流动过程。 按照推荐的方式使用，只有很少的组件依赖 Redux ; 其它的组件只接收状态和回调作为属性。这么做可以保持组件非常简单，减少框架同步。 这儿有几个库配合 Redux 非常爽，我也推荐你使用： Immutable.js JavaScript 不可变数据结构！用它存储你的状态，可以确保状态不会在不该改变的时候改变，并且能够保障 reducer 足够纯洁。 redux-thunk 当你的 actions 不只是更新应用状态，还有其他副作用时，就派上用场。比如，调用 REST API，设置路由或者派发其他 actions reselect 用于可组合的，懒计算的情形。例如，对于部分组件，你可能想要: 只注入整个状态树的相关部分，而非整个 注入额外的衍生数据，比如总数或验证状态，而不需放在 store 中 没有必要在最开始的时候就把这些全部引进来。当你开始有状态时，就可以引入 Redux 和 Immutable.js，有派生状态时引入 reselect，有路由或异步 actions 时引入 redux-thunk。尽早在必要时引入可以省去之后重构的时间。 Redux 是不是真正的 Flux，每个人都有自己的见解。个人觉得它符合 Flux 框架的核心思想，不过这个争论只是个语义问题。 6. 一直使用 propTypespropTypes 很容易为组件添加类型安全保障。他们看起来像这样：1234567891011121314const ListOfNumbers = props =&gt; ( &lt;ol className={props.className}&gt; { props.numbers.map(number =&gt; ( &lt;li&gt;{number}&lt;/li&gt;) ) } &lt;/ol&gt;);ListOfNumbers.propTypes = { className: React.PropTypes.string.isRequired, numbers: React.PropTypes.arrayOf(React.PropTypes.number)}; 在开发阶段（生产不会），如果任何组件没有给到必需的属性，或者所给的属性与声明的不匹配，React 会打印这些错误信息通知你。这有几点好处： 防止低级错误，捕获 bugs 如果你使用 isRequired，你就不需要检查 undefined 或 null 就像文档所说，列出组件的所有属性，省去阅读代码的人搜索整个组件。 上面的这些点，你可能似曾相识，静态类型支持者的论点。个人来讲，我通常喜欢动态类型带来的开发速度和舒适，但是我发现 propTypes 可以毫不费力的为我的组件添加一些安全感。坦白讲，没有理由不一直用它们。最后一点是，任何 propType 错误时，让你的测试用例失败。下面这个例子有点简单粗暴的，不过可行：12345beforeAll(() =&gt; { console.error = error =&gt; { throw new Error(error); };}); 7. 使用浅渲染测试 React 组件依然是有点棘手的话题。不是因为太难，而是因为还在发展，还没有出现一个最佳方案。目前来看，我的 go-to 方法是使用 浅渲染和属性断言。 浅渲染很好用，它允许你完整的渲染一个单一组件，而不涉及子元素的渲染。也就是说，结果对象只会告诉你子元素的类型和属性。这样子单一组件单一时间点可以提供很好的隔离。这儿有三种类型的组件单元测试，我自己也经常这么做： 渲染逻辑假定一个组件，因条件不同，可能会显示一张图片，或者一个加载图标：1234567const Image = props =&gt; { if (props.loading) { return &lt;LoadingIcon/&gt;; } return &lt;img src={props.src}/&gt;;}; 我们可以这么测试：12345678910111213describe('Image', () =&gt; { it('renders a loading icon when the image is loading', () =&gt; { const image = shallowRender(&lt;Image loading={true}/&gt;); expect(image.type).toEqual(LoadingIcon); }); it('renders the image once it has loaded', () =&gt; { const image = shallowRender(&lt;Image loading={false} src=\"https://example.com/image.jpg\"/&gt;); expect(image.type).toEqual('img'); });}); 非常简单！当然，浅渲染的API 略微比我展示的复杂。上面使用的浅渲染函数是我们自己的 辅助方法，这个辅助方法包装了真正的 API，使用起来更简单一些。回头看下我们的 ListOfNumbers 组件，下面是我们如何测试映射结果确实正确：1234567describe('ListOfNumbers', () =&gt; { it('renders an item for each provided number', () =&gt; { const listOfNumbers = shallowRender(&lt;ListOfNumbers className=\"red\" numbers={[3, 4, 5, 6]}/&gt;); expect(listOfNumbers.props.children.length).toEqual(4); });}); 属性转换在最后的例子中，我们深入测试组件的子元素，确保它们被正确渲染。我们不止断言组件是否存在，同时检查所给的属性是否正确。当组件确实在传递属性之前根据属性做些转换时，这点特别有用。例如，下面这个组件接受一个字符串数组作为 CSS 类名，往下传递一个单引号空白分割的字符串：123456789101112131415161718const TextWithArrayOfClassNames = props =&gt; ( &lt;div&gt; &lt;p className={props.classNames.join(' ')}&gt; {props.text} &lt;/p&gt; &lt;/div&gt;);describe('TextWithArrayOfClassNames', () =&gt; { it('turns the array into a space-separated string', () =&gt; { const text = 'Hello, world!'; const classNames = ['red', 'bold', 'float-right']; const textWithArrayOfClassNames = shallowRender(&lt;TextWithArrayOfClassNames text={text} classNames={classNames}/&gt;); const childClassNames = textWithArrayOfClassNames.props.children.props.className; expect(childClassNames).toEqual('red bold float-right'); });}); 对这样方法最多的批判是激增的 props.children.props.children 。当然这不是最完美的代码，个人觉得如果一个测试中的 props.children 多的让人受不了，这说明这个组件太大了，太复杂了，嵌套太深。它可能需要拆分。另外一点，我经常听说的是，你的测试太依赖你的组件内部实现，以至于稍微改变你的 DOM 结构都能导致你所有的测试崩溃。这的确是一个很公正的评论，脆弱的测试套件是每个人想要的最好件事。管理这些最好的方式是保持你的组件足够小，足够简单，应该控制因组件变更引起的测试崩溃数目。 用户交互当然，组件不止展示，还有交互：123const RedInput = props =&gt; ( &lt;input className=\"red\" onChange={props.onChange} /&gt;) 这是我最喜欢的测试方法：123456789describe('RedInput', () =&gt; { it('passes the event to the given callback when the value changes', () =&gt; { const callback = jasmine.createSpy(); const redInput = shallowRender(&lt;RedInput onChange={callback}/&gt;); redInput.props.onChange('an event!'); expect(callback).toHaveBeenCalledWith('an event!'); });}); 这只是一个例子，希望你能受到启发。 集成测试上面我内容只覆盖到组件的独立的单元测试，但是你可能想确保你的应用各个部分协同工作，想在测试上走的更远。我对这部分了解的不够深入，但是列出一些基本点： 渲染你的整个组件树（而非浅渲染） 访问 DOM （使用 React TestUtils 或 jQuery 等等）找到你最关系的元素，然后 断言元素的 HTML 属性和内容 模拟 DOM 事件，然后断言产生的效果（DOM 或 路由变化，AJAX 调用等等） 关于测试驱动开发一般情况下，写React 组件时我并不使用测试驱动开发。 在开发组件的时候，我发现我经常会去改动它的结构，我需要使用最简单的 HTML 和 CSS，在需要支持的浏览器上保持一致。因为我的组件单元测试方法大多会断言组件的结构，而测试驱动开发会使我在修改DOM时，忙于修复测试用例，这看起来有点浪费时间。另外一个因素是组件足够简单以至于测试优先的有点基本消失。所有复杂的逻辑和转换都会丢在 action creators 和 reducers，这些地方我能真正享受到测试驱动开发带来的便利。关于测试还有最后一点需要说明。整节内容我都在讨论测试组件，是因为测试基于 Redux 应用的其它部分没有特别之处。作为一个框架，Redux 背后还有些 ‘魔力’ ，可以减少对 mock 和其它测试模板的依赖。每个函数只是一个普通的函数（大多数是纯函数），测试起来真是如沐春风。 8. 使用 JSX, ES6, Babel, Webpack 和 NPM只有 JSX 是 React 特有的。对我来说，JSX 是 React.createElement 的无脑操作。唯一的不足是增加了构建的复杂度，这个问题可以用 Babel 轻松搞定。既然用了 Babel，那没理由不用 ES6 特性，像 常量，箭头函数，默认参数，数组和对象解构，延展和 rest 操作，字符串模板，迭代器和生成器，模块系统，等等。只要你花一点时间设置这个工具，你就能感受到 JavaScript 语言越来越成熟。让我们做的更全面一些，使用 Webpack 打包代码，使用 NPM 管理包。现在我们完全赶上了 JavaScript 的潮流 :)。 9. 使用 React 和 Redux 开发工具谈到工具，React 和 Redux 的开发工具太赞了。React dev tools 让你审查 React 元素的渲染树，在查看浏览器中结果时相当有用。Redux dev tools 更是让人眼前一亮，让你看到每个 已经发生的 action ，它们引起的状态变化，甚至给你回退的能力！你可以作为开发依赖，或者浏览器扩展的形式使用。你也可以用webpack设置热切换，保存代码时你的页面也会跟着更新-浏览器无需刷新。在调整组件和 reducers 时可以立即看到效果，大大提高开发效率。 就这些！我希望在 React 入门上能带给你一个好的开端，帮你避免一些常见的错误。如果你喜欢这篇文档，可以关注我的Twitter 或者订阅我的 RSS 。","link":"/2016/07/18/【翻译】React-js-初学者应该知道的-9-件事/"}],"tags":[{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"调研 MVVM","slug":"调研-MVVM","link":"/tags/调研-MVVM/"},{"name":"AngularJS","slug":"AngularJS","link":"/tags/AngularJS/"},{"name":"AngularJS lazyload","slug":"AngularJS-lazyload","link":"/tags/AngularJS-lazyload/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"MutationObserver","slug":"MutationObserver","link":"/tags/MutationObserver/"},{"name":"前端工程化","slug":"前端工程化","link":"/tags/前端工程化/"},{"name":"前端错误","slug":"前端错误","link":"/tags/前端错误/"},{"name":"设计","slug":"设计","link":"/tags/设计/"},{"name":"template","slug":"template","link":"/tags/template/"},{"name":"Module SeaJS","slug":"Module-SeaJS","link":"/tags/Module-SeaJS/"},{"name":"阅读笔记","slug":"阅读笔记","link":"/tags/阅读笔记/"},{"name":"CDN共享","slug":"CDN共享","link":"/tags/CDN共享/"},{"name":"组件","slug":"组件","link":"/tags/组件/"},{"name":"框架","slug":"框架","link":"/tags/框架/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"AngularJs","slug":"AngularJs","link":"/tags/AngularJs/"},{"name":"业务流程","slug":"业务流程","link":"/tags/业务流程/"},{"name":"秒杀","slug":"秒杀","link":"/tags/秒杀/"},{"name":"mobile video","slug":"mobile-video","link":"/tags/mobile-video/"},{"name":"MobX","slug":"MobX","link":"/tags/MobX/"},{"name":"js模式","slug":"js模式","link":"/tags/js模式/"},{"name":"翻译","slug":"翻译","link":"/tags/翻译/"},{"name":"React","slug":"React","link":"/tags/React/"}],"categories":[{"name":"心得总结","slug":"心得总结","link":"/categories/心得总结/"},{"name":"翻译","slug":"翻译","link":"/categories/翻译/"},{"name":"积累","slug":"积累","link":"/categories/积累/"},{"name":"造轮子","slug":"造轮子","link":"/categories/造轮子/"},{"name":"总结","slug":"总结","link":"/categories/总结/"},{"name":"移动端","slug":"移动端","link":"/categories/移动端/"}]}